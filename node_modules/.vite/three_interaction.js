import {
  EventDispatcher,
  Object3D,
  Raycaster,
  Vector2
} from "./chunk-CIHW4WCD.js";
import "./chunk-76J2PTFD.js";

// node_modules/three.interaction/build/three.interaction.module.js
function _rt(val) {
  return Object.prototype.toString.call(val);
}
var Utils = {
  isFunction: function() {
    var ks = _rt(function() {
    });
    return function(variable) {
      return _rt(variable) === ks;
    };
  }(),
  isUndefined: function isUndefined(variable) {
    return typeof variable === "undefined";
  }
};
EventDispatcher.prototype.on = function(type, fn) {
  if (!Utils.isFunction(fn))
    return;
  if (this instanceof Object3D)
    this.interactive = true;
  this.addEventListener(type, fn);
  return this;
};
EventDispatcher.prototype.off = function(type, fn) {
  this.removeEventListener(type, fn);
  return this;
};
EventDispatcher.prototype.once = function(type, fn) {
  var _this = this;
  if (!Utils.isFunction(fn))
    return;
  var cb = function cb2(ev) {
    fn(ev);
    _this.off(type, cb2);
  };
  this.on(type, cb);
  return this;
};
EventDispatcher.prototype.emit = function(type) {
  if (this._listeners === void 0 || Utils.isUndefined(this._listeners[type]))
    return;
  var cbs = this._listeners[type] || [];
  var cache = cbs.slice(0);
  for (var _len = arguments.length, argument = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    argument[_key - 1] = arguments[_key];
  }
  for (var i = 0; i < cache.length; i++) {
    cache[i].apply(this, argument);
  }
  return this;
};
Object3D.prototype.interactive = false;
Object3D.prototype.interactiveChildren = true;
Object3D.prototype.started = false;
Object.defineProperty(Object3D.prototype, "trackedPointers", {
  get: function get() {
    if (!this._trackedPointers)
      this._trackedPointers = {};
    return this._trackedPointers;
  }
});
Object3D.prototype.raycastTest = function(raycaster) {
  var result = [];
  this.raycast(raycaster, result);
  if (result.length > 0) {
    return result[0];
  }
  return false;
};
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var classCallCheck = function(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};
var createClass = function() {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
var inherits = function(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};
var possibleConstructorReturn = function(self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};
var InteractionData = function() {
  function InteractionData2() {
    classCallCheck(this, InteractionData2);
    this.global = new Vector2();
    this.target = null;
    this.originalEvent = null;
    this.identifier = null;
    this.isPrimary = false;
    this.button = 0;
    this.buttons = 0;
    this.width = 0;
    this.height = 0;
    this.tiltX = 0;
    this.tiltY = 0;
    this.pointerType = null;
    this.pressure = 0;
    this.rotationAngle = 0;
    this.twist = 0;
    this.tangentialPressure = 0;
  }
  createClass(InteractionData2, [{
    key: "_copyEvent",
    value: function _copyEvent(event) {
      if (event.isPrimary) {
        this.isPrimary = true;
      }
      this.button = event.button;
      this.buttons = event.buttons;
      this.width = event.width;
      this.height = event.height;
      this.tiltX = event.tiltX;
      this.tiltY = event.tiltY;
      this.pointerType = event.pointerType;
      this.pressure = event.pressure;
      this.rotationAngle = event.rotationAngle;
      this.twist = event.twist || 0;
      this.tangentialPressure = event.tangentialPressure || 0;
    }
  }, {
    key: "_reset",
    value: function _reset() {
      this.isPrimary = false;
    }
  }, {
    key: "pointerId",
    get: function get$$1() {
      return this.identifier;
    }
  }]);
  return InteractionData2;
}();
var InteractionEvent = function() {
  function InteractionEvent2() {
    classCallCheck(this, InteractionEvent2);
    this.stopped = false;
    this.target = null;
    this.currentTarget = null;
    this.type = null;
    this.data = null;
    this.intersects = [];
  }
  createClass(InteractionEvent2, [{
    key: "stopPropagation",
    value: function stopPropagation() {
      this.stopped = true;
    }
  }, {
    key: "_reset",
    value: function _reset() {
      this.stopped = false;
      this.currentTarget = null;
      this.target = null;
      this.intersects = [];
    }
  }]);
  return InteractionEvent2;
}();
var InteractionTrackingData = function() {
  function InteractionTrackingData2(pointerId) {
    classCallCheck(this, InteractionTrackingData2);
    this._pointerId = pointerId;
    this._flags = InteractionTrackingData2.FLAGS.NONE;
  }
  createClass(InteractionTrackingData2, [{
    key: "_doSet",
    value: function _doSet(flag, yn) {
      if (yn) {
        this._flags = this._flags | flag;
      } else {
        this._flags = this._flags & ~flag;
      }
    }
  }, {
    key: "pointerId",
    get: function get$$1() {
      return this._pointerId;
    }
  }, {
    key: "flags",
    get: function get$$1() {
      return this._flags;
    },
    set: function set$$1(flags) {
      this._flags = flags;
    }
  }, {
    key: "none",
    get: function get$$1() {
      return this._flags === this.constructor.FLAGS.NONE;
    }
  }, {
    key: "over",
    get: function get$$1() {
      return (this._flags & this.constructor.FLAGS.OVER) !== 0;
    },
    set: function set$$1(yn) {
      this._doSet(this.constructor.FLAGS.OVER, yn);
    }
  }, {
    key: "rightDown",
    get: function get$$1() {
      return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;
    },
    set: function set$$1(yn) {
      this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);
    }
  }, {
    key: "leftDown",
    get: function get$$1() {
      return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;
    },
    set: function set$$1(yn) {
      this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);
    }
  }]);
  return InteractionTrackingData2;
}();
InteractionTrackingData.FLAGS = Object.freeze({
  NONE: 0,
  OVER: 1 << 0,
  LEFT_DOWN: 1 << 1,
  RIGHT_DOWN: 1 << 2
});
var MOUSE_POINTER_ID = "MOUSE";
var hitTestEvent = {
  target: null,
  data: {
    global: null
  }
};
var InteractionManager = function(_EventDispatcher) {
  inherits(InteractionManager2, _EventDispatcher);
  function InteractionManager2(renderer, scene, camera, options) {
    classCallCheck(this, InteractionManager2);
    var _this = possibleConstructorReturn(this, (InteractionManager2.__proto__ || Object.getPrototypeOf(InteractionManager2)).call(this));
    options = options || {};
    _this.renderer = renderer;
    _this.scene = scene;
    _this.camera = camera;
    _this.autoPreventDefault = options.autoPreventDefault || false;
    _this.interactionFrequency = options.interactionFrequency || 10;
    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID;
    _this.mouse.global.set(-999999);
    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID] = _this.mouse;
    _this.interactionDataPool = [];
    _this.eventData = new InteractionEvent();
    _this.interactionDOMElement = null;
    _this.moveWhenInside = true;
    _this.eventsAdded = false;
    _this.mouseOverRenderer = false;
    _this.supportsTouchEvents = "ontouchstart" in window;
    _this.supportsPointerEvents = !!window.PointerEvent;
    _this.onClick = _this.onClick.bind(_this);
    _this.processClick = _this.processClick.bind(_this);
    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    _this.onPointerOver = _this.onPointerOver.bind(_this);
    _this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    _this.currentCursorMode = null;
    _this.cursor = null;
    _this.raycaster = new Raycaster();
    _this._deltaTime = 0;
    _this.setTargetElement(_this.renderer.domElement);
    return _this;
  }
  createClass(InteractionManager2, [{
    key: "hitTest",
    value: function hitTest(globalPoint, root) {
      hitTestEvent.target = null;
      hitTestEvent.data.global = globalPoint;
      if (!root) {
        root = this.scene;
      }
      this.processInteractive(hitTestEvent, root, null, true);
      return hitTestEvent.target;
    }
  }, {
    key: "setTargetElement",
    value: function setTargetElement(element) {
      this.removeEvents();
      this.interactionDOMElement = element;
      this.addEvents();
    }
  }, {
    key: "addEvents",
    value: function addEvents() {
      if (!this.interactionDOMElement || this.eventsAdded) {
        return;
      }
      this.emit("addevents");
      this.interactionDOMElement.addEventListener("click", this.onClick, true);
      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style["-ms-content-zooming"] = "none";
        this.interactionDOMElement.style["-ms-touch-action"] = "none";
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style["touch-action"] = "none";
      }
      if (this.supportsPointerEvents) {
        window.document.addEventListener("pointermove", this.onPointerMove, true);
        this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, true);
        this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, true);
        this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, true);
        window.addEventListener("pointercancel", this.onPointerCancel, true);
        window.addEventListener("pointerup", this.onPointerUp, true);
      } else {
        window.document.addEventListener("mousemove", this.onPointerMove, true);
        this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, true);
        this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, true);
        this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, true);
        window.addEventListener("mouseup", this.onPointerUp, true);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, true);
        this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, true);
        this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, true);
        this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, true);
      }
      this.eventsAdded = true;
    }
  }, {
    key: "removeEvents",
    value: function removeEvents() {
      if (!this.interactionDOMElement) {
        return;
      }
      this.emit("removeevents");
      this.interactionDOMElement.removeEventListener("click", this.onClick, true);
      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style["-ms-content-zooming"] = "";
        this.interactionDOMElement.style["-ms-touch-action"] = "";
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style["touch-action"] = "";
      }
      if (this.supportsPointerEvents) {
        window.document.removeEventListener("pointermove", this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, true);
        window.removeEventListener("pointercancel", this.onPointerCancel, true);
        window.removeEventListener("pointerup", this.onPointerUp, true);
      } else {
        window.document.removeEventListener("mousemove", this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, true);
        window.removeEventListener("mouseup", this.onPointerUp, true);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, true);
        this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, true);
        this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, true);
      }
      this.interactionDOMElement = null;
      this.eventsAdded = false;
    }
  }, {
    key: "update",
    value: function update(_ref) {
      var snippet = _ref.snippet;
      this._deltaTime += snippet;
      if (this._deltaTime < this.interactionFrequency) {
        return;
      }
      this._deltaTime = 0;
      if (!this.interactionDOMElement) {
        return;
      }
      if (this.didMove) {
        this.didMove = false;
        return;
      }
      this.cursor = null;
      for (var k in this.activeInteractionData) {
        if (this.activeInteractionData.hasOwnProperty(k)) {
          var interactionData = this.activeInteractionData[k];
          if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
            this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, true);
          }
        }
      }
      this.setCursorMode(this.cursor);
    }
  }, {
    key: "setCursorMode",
    value: function setCursorMode(mode) {
      mode = mode || "default";
      if (this.currentCursorMode === mode) {
        return;
      }
      this.currentCursorMode = mode;
      var style = this.cursorStyles[mode];
      if (style) {
        switch (typeof style === "undefined" ? "undefined" : _typeof(style)) {
          case "string":
            this.interactionDOMElement.style.cursor = style;
            break;
          case "function":
            style(mode);
            break;
          case "object":
            Object.assign(this.interactionDOMElement.style, style);
            break;
          default:
            break;
        }
      } else if (typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        this.interactionDOMElement.style.cursor = mode;
      }
    }
  }, {
    key: "triggerEvent",
    value: function triggerEvent(displayObject, eventString, eventData) {
      if (!eventData.stopped) {
        eventData.currentTarget = displayObject;
        eventData.type = eventString;
        displayObject.emit(eventString, eventData);
        if (displayObject[eventString]) {
          displayObject[eventString](eventData);
        }
      }
    }
  }, {
    key: "processInteractive",
    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {
      if (!displayObject || !displayObject.visible) {
        return false;
      }
      interactive = displayObject.interactive || interactive;
      var hit = false;
      var interactiveParent = interactive;
      if (displayObject.interactiveChildren && displayObject.children) {
        var children = displayObject.children;
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
          if (childHit) {
            if (!child.parent) {
              continue;
            }
            interactiveParent = false;
            if (childHit) {
              if (interactionEvent.target) {
                hitTest = false;
              }
              hit = true;
            }
          }
        }
      }
      if (interactive) {
        if (hitTest && !interactionEvent.target) {
          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {
            hit = true;
          }
        }
        if (displayObject.interactive) {
          if (hit && !interactionEvent.target) {
            interactionEvent.data.target = interactionEvent.target = displayObject;
          }
          if (func) {
            func(interactionEvent, displayObject, !!hit);
          }
        }
      }
      return hit;
    }
  }, {
    key: "onClick",
    value: function onClick(originalEvent) {
      if (originalEvent.type !== "click")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }
      var interactionData = this.getInteractionDataForPointerId(events[0]);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.scene, this.processClick, true);
      this.emit("click", interactionEvent);
    }
  }, {
    key: "processClick",
    value: function processClick(interactionEvent, displayObject, hit) {
      if (hit) {
        this.triggerEvent(displayObject, "click", interactionEvent);
      }
    }
  }, {
    key: "onPointerDown",
    value: function onPointerDown(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }
      var eventLen = events.length;
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);
        this.emit("pointerdown", interactionEvent);
        if (event.pointerType === "touch") {
          this.emit("touchstart", interactionEvent);
        } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
        }
      }
    }
  }, {
    key: "processPointerDown",
    value: function processPointerDown(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      if (hit) {
        if (!displayObject.trackedPointers[id]) {
          displayObject.trackedPointers[id] = new InteractionTrackingData(id);
        }
        this.triggerEvent(displayObject, "pointerdown", interactionEvent);
        if (data.pointerType === "touch") {
          displayObject.started = true;
          this.triggerEvent(displayObject, "touchstart", interactionEvent);
        } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
          var isRightButton = data.button === 2;
          if (isRightButton) {
            displayObject.trackedPointers[id].rightDown = true;
          } else {
            displayObject.trackedPointers[id].leftDown = true;
          }
          this.triggerEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
        }
      }
    }
  }, {
    key: "onPointerComplete",
    value: function onPointerComplete(originalEvent, cancelled, func) {
      var events = this.normalizeToPointerData(originalEvent);
      var eventLen = events.length;
      var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);
        this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
        } else if (event.pointerType === "touch") {
          this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);
        }
      }
    }
  }, {
    key: "onPointerCancel",
    value: function onPointerCancel(event) {
      if (this.supportsTouchEvents && event.pointerType === "touch")
        return;
      this.onPointerComplete(event, true, this.processPointerCancel);
    }
  }, {
    key: "processPointerCancel",
    value: function processPointerCancel(interactionEvent, displayObject) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      if (displayObject.trackedPointers[id] !== void 0) {
        delete displayObject.trackedPointers[id];
        this.triggerEvent(displayObject, "pointercancel", interactionEvent);
        if (data.pointerType === "touch") {
          this.triggerEvent(displayObject, "touchcancel", interactionEvent);
        }
      }
    }
  }, {
    key: "onPointerUp",
    value: function onPointerUp(event) {
      if (this.supportsTouchEvents && event.pointerType === "touch")
        return;
      this.onPointerComplete(event, false, this.processPointerUp);
    }
  }, {
    key: "processPointerUp",
    value: function processPointerUp(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var trackingData = displayObject.trackedPointers[id];
      var isTouch = data.pointerType === "touch";
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      if (isMouse) {
        var isRightButton = data.button === 2;
        var flags = InteractionTrackingData.FLAGS;
        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
        var isDown = trackingData !== void 0 && trackingData.flags & test;
        if (hit) {
          this.triggerEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
          if (isDown) {
            this.triggerEvent(displayObject, isRightButton ? "rightclick" : "leftclick", interactionEvent);
          }
        } else if (isDown) {
          this.triggerEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
        }
        if (trackingData) {
          if (isRightButton) {
            trackingData.rightDown = false;
          } else {
            trackingData.leftDown = false;
          }
        }
      }
      if (isTouch && displayObject.started) {
        displayObject.started = false;
        this.triggerEvent(displayObject, "touchend", interactionEvent);
      }
      if (hit) {
        this.triggerEvent(displayObject, "pointerup", interactionEvent);
        if (trackingData) {
          this.triggerEvent(displayObject, "pointertap", interactionEvent);
          if (isTouch) {
            this.triggerEvent(displayObject, "tap", interactionEvent);
            trackingData.over = false;
          }
        }
      } else if (trackingData) {
        this.triggerEvent(displayObject, "pointerupoutside", interactionEvent);
        if (isTouch)
          this.triggerEvent(displayObject, "touchendoutside", interactionEvent);
      }
      if (trackingData && trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
  }, {
    key: "onPointerMove",
    value: function onPointerMove(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      if (events[0].pointerType === "mouse") {
        this.didMove = true;
        this.cursor = null;
      }
      var eventLen = events.length;
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        var interactive = event.pointerType === "touch" ? this.moveWhenInside : true;
        this.processInteractive(interactionEvent, this.scene, this.processPointerMove, interactive);
        this.emit("pointermove", interactionEvent);
        if (event.pointerType === "touch")
          this.emit("touchmove", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen")
          this.emit("mousemove", interactionEvent);
      }
      if (events[0].pointerType === "mouse") {
        this.setCursorMode(this.cursor);
      }
    }
  }, {
    key: "processPointerMove",
    value: function processPointerMove(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var isTouch = data.pointerType === "touch";
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      if (isMouse) {
        this.processPointerOverOut(interactionEvent, displayObject, hit);
      }
      if (isTouch && displayObject.started)
        this.triggerEvent(displayObject, "touchmove", interactionEvent);
      if (!this.moveWhenInside || hit) {
        this.triggerEvent(displayObject, "pointermove", interactionEvent);
        if (isMouse)
          this.triggerEvent(displayObject, "mousemove", interactionEvent);
      }
    }
  }, {
    key: "onPointerOut",
    value: function onPointerOut(originalEvent) {
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = false;
        this.setCursorMode(null);
      }
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);
      this.emit("pointerout", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseout", interactionEvent);
      } else {
        this.releaseInteractionDataForPointerId(interactionData.identifier);
      }
    }
  }, {
    key: "processPointerOverOut",
    value: function processPointerOverOut(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      var trackingData = displayObject.trackedPointers[id];
      if (hit && !trackingData) {
        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }
      if (trackingData === void 0)
        return;
      if (hit && this.mouseOverRenderer) {
        if (!trackingData.over) {
          trackingData.over = true;
          this.triggerEvent(displayObject, "pointerover", interactionEvent);
          if (isMouse) {
            this.triggerEvent(displayObject, "mouseover", interactionEvent);
          }
        }
        if (isMouse && this.cursor === null) {
          this.cursor = displayObject.cursor;
        }
      } else if (trackingData.over) {
        trackingData.over = false;
        this.triggerEvent(displayObject, "pointerout", this.eventData);
        if (isMouse) {
          this.triggerEvent(displayObject, "mouseout", interactionEvent);
        }
        if (trackingData.none) {
          delete displayObject.trackedPointers[id];
        }
      }
    }
  }, {
    key: "onPointerOver",
    value: function onPointerOver(originalEvent) {
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = true;
      }
      this.emit("pointerover", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseover", interactionEvent);
      }
    }
  }, {
    key: "getInteractionDataForPointerId",
    value: function getInteractionDataForPointerId(event) {
      var pointerId = event.pointerId;
      var interactionData = void 0;
      if (pointerId === MOUSE_POINTER_ID || event.pointerType === "mouse") {
        interactionData = this.mouse;
      } else if (this.activeInteractionData[pointerId]) {
        interactionData = this.activeInteractionData[pointerId];
      } else {
        interactionData = this.interactionDataPool.pop() || new InteractionData();
        interactionData.identifier = pointerId;
        this.activeInteractionData[pointerId] = interactionData;
      }
      interactionData._copyEvent(event);
      return interactionData;
    }
  }, {
    key: "releaseInteractionDataForPointerId",
    value: function releaseInteractionDataForPointerId(pointerId) {
      var interactionData = this.activeInteractionData[pointerId];
      if (interactionData) {
        delete this.activeInteractionData[pointerId];
        interactionData._reset();
        this.interactionDataPool.push(interactionData);
      }
    }
  }, {
    key: "mapPositionToPoint",
    value: function mapPositionToPoint(point, x, y) {
      var rect = void 0;
      if (!this.interactionDOMElement.parentElement) {
        rect = {
          x: 0,
          y: 0,
          left: 0,
          top: 0,
          width: 0,
          height: 0
        };
      } else {
        rect = this.interactionDOMElement.getBoundingClientRect();
      }
      point.x = (x - rect.left) / rect.width * 2 - 1;
      point.y = -((y - rect.top) / rect.height) * 2 + 1;
    }
  }, {
    key: "configureInteractionEventForDOMEvent",
    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
      interactionEvent.data = interactionData;
      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
      this.raycaster.setFromCamera(interactionData.global, this.camera);
      if (pointerEvent.pointerType === "touch") {
        pointerEvent.globalX = interactionData.global.x;
        pointerEvent.globalY = interactionData.global.y;
      }
      interactionData.originalEvent = pointerEvent;
      interactionEvent._reset();
      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);
      return interactionEvent;
    }
  }, {
    key: "normalizeToPointerData",
    value: function normalizeToPointerData(event) {
      var normalizedEvents = [];
      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (var i = 0, li = event.changedTouches.length; i < li; i++) {
          var touch = event.changedTouches[i];
          if (typeof touch.button === "undefined")
            touch.button = event.touches.length ? 1 : 0;
          if (typeof touch.buttons === "undefined")
            touch.buttons = event.touches.length ? 1 : 0;
          if (typeof touch.isPrimary === "undefined") {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (typeof touch.width === "undefined")
            touch.width = touch.radiusX || 1;
          if (typeof touch.height === "undefined")
            touch.height = touch.radiusY || 1;
          if (typeof touch.tiltX === "undefined")
            touch.tiltX = 0;
          if (typeof touch.tiltY === "undefined")
            touch.tiltY = 0;
          if (typeof touch.pointerType === "undefined")
            touch.pointerType = "touch";
          if (typeof touch.pointerId === "undefined")
            touch.pointerId = touch.identifier || 0;
          if (typeof touch.pressure === "undefined")
            touch.pressure = touch.force || 0.5;
          touch.twist = 0;
          touch.tangentialPressure = 0;
          if (typeof touch.layerX === "undefined")
            touch.layerX = touch.offsetX = touch.clientX;
          if (typeof touch.layerY === "undefined")
            touch.layerY = touch.offsetY = touch.clientY;
          touch.isNormalized = true;
          normalizedEvents.push(touch);
        }
      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
        if (typeof event.isPrimary === "undefined")
          event.isPrimary = true;
        if (typeof event.width === "undefined")
          event.width = 1;
        if (typeof event.height === "undefined")
          event.height = 1;
        if (typeof event.tiltX === "undefined")
          event.tiltX = 0;
        if (typeof event.tiltY === "undefined")
          event.tiltY = 0;
        if (typeof event.pointerType === "undefined")
          event.pointerType = "mouse";
        if (typeof event.pointerId === "undefined")
          event.pointerId = MOUSE_POINTER_ID;
        if (typeof event.pressure === "undefined")
          event.pressure = 0.5;
        event.twist = 0;
        event.tangentialPressure = 0;
        event.isNormalized = true;
        normalizedEvents.push(event);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeEvents();
      this.removeAllListeners();
      this.renderer = null;
      this.mouse = null;
      this.eventData = null;
      this.interactionDOMElement = null;
      this.onPointerDown = null;
      this.processPointerDown = null;
      this.onPointerUp = null;
      this.processPointerUp = null;
      this.onPointerCancel = null;
      this.processPointerCancel = null;
      this.onPointerMove = null;
      this.processPointerMove = null;
      this.onPointerOut = null;
      this.processPointerOverOut = null;
      this.onPointerOver = null;
      this._tempPoint = null;
    }
  }]);
  return InteractionManager2;
}(EventDispatcher);
var MOUSE_POINTER_ID$1 = "MOUSE";
var hitTestEvent$1 = {
  target: null,
  data: {
    global: null
  }
};
var InteractionLayer = function(_EventDispatcher) {
  inherits(InteractionLayer2, _EventDispatcher);
  function InteractionLayer2(renderer, options) {
    classCallCheck(this, InteractionLayer2);
    var _this = possibleConstructorReturn(this, (InteractionLayer2.__proto__ || Object.getPrototypeOf(InteractionLayer2)).call(this));
    options = options || {};
    _this.renderer = renderer;
    _this.layer = null;
    _this.autoPreventDefault = options.autoPreventDefault || false;
    _this.interactionFrequency = options.interactionFrequency || 10;
    _this.mouse = new InteractionData();
    _this.mouse.identifier = MOUSE_POINTER_ID$1;
    _this.mouse.global.set(-999999);
    _this.activeInteractionData = {};
    _this.activeInteractionData[MOUSE_POINTER_ID$1] = _this.mouse;
    _this.interactionDataPool = [];
    _this.eventData = new InteractionEvent();
    _this.interactionDOMElement = null;
    _this.moveWhenInside = true;
    _this.eventsAdded = false;
    _this.mouseOverRenderer = false;
    _this.supportsTouchEvents = "ontouchstart" in window;
    _this.supportsPointerEvents = !!window.PointerEvent;
    _this.onClick = _this.onClick.bind(_this);
    _this.processClick = _this.processClick.bind(_this);
    _this.onPointerUp = _this.onPointerUp.bind(_this);
    _this.processPointerUp = _this.processPointerUp.bind(_this);
    _this.onPointerCancel = _this.onPointerCancel.bind(_this);
    _this.processPointerCancel = _this.processPointerCancel.bind(_this);
    _this.onPointerDown = _this.onPointerDown.bind(_this);
    _this.processPointerDown = _this.processPointerDown.bind(_this);
    _this.onPointerMove = _this.onPointerMove.bind(_this);
    _this.processPointerMove = _this.processPointerMove.bind(_this);
    _this.onPointerOut = _this.onPointerOut.bind(_this);
    _this.processPointerOverOut = _this.processPointerOverOut.bind(_this);
    _this.onPointerOver = _this.onPointerOver.bind(_this);
    _this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    };
    _this.currentCursorMode = null;
    _this.cursor = null;
    _this.raycaster = new Raycaster();
    _this._deltaTime = 0;
    _this.setTargetElement(_this.renderer.domElement);
    return _this;
  }
  createClass(InteractionLayer2, [{
    key: "isAble",
    value: function isAble() {
      return this.layer && this.layer.interactive;
    }
  }, {
    key: "setLayer",
    value: function setLayer(layer) {
      this.layer = layer;
    }
  }, {
    key: "hitTest",
    value: function hitTest(globalPoint, root) {
      if (!this.isAble())
        return null;
      hitTestEvent$1.target = null;
      hitTestEvent$1.data.global = globalPoint;
      if (!root) {
        root = this.layer.scene;
      }
      this.processInteractive(hitTestEvent$1, root, null, true);
      return hitTestEvent$1.target;
    }
  }, {
    key: "setTargetElement",
    value: function setTargetElement(element) {
      this.removeEvents();
      this.interactionDOMElement = element;
      this.addEvents();
    }
  }, {
    key: "addEvents",
    value: function addEvents() {
      if (!this.interactionDOMElement || this.eventsAdded) {
        return;
      }
      this.emit("addevents");
      this.interactionDOMElement.addEventListener("click", this.onClick, true);
      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style["-ms-content-zooming"] = "none";
        this.interactionDOMElement.style["-ms-touch-action"] = "none";
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style["touch-action"] = "none";
      }
      if (this.supportsPointerEvents) {
        window.document.addEventListener("pointermove", this.onPointerMove, true);
        this.interactionDOMElement.addEventListener("pointerdown", this.onPointerDown, true);
        this.interactionDOMElement.addEventListener("pointerleave", this.onPointerOut, true);
        this.interactionDOMElement.addEventListener("pointerover", this.onPointerOver, true);
        window.addEventListener("pointercancel", this.onPointerCancel, true);
        window.addEventListener("pointerup", this.onPointerUp, true);
      } else {
        window.document.addEventListener("mousemove", this.onPointerMove, true);
        this.interactionDOMElement.addEventListener("mousedown", this.onPointerDown, true);
        this.interactionDOMElement.addEventListener("mouseout", this.onPointerOut, true);
        this.interactionDOMElement.addEventListener("mouseover", this.onPointerOver, true);
        window.addEventListener("mouseup", this.onPointerUp, true);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.addEventListener("touchstart", this.onPointerDown, true);
        this.interactionDOMElement.addEventListener("touchcancel", this.onPointerCancel, true);
        this.interactionDOMElement.addEventListener("touchend", this.onPointerUp, true);
        this.interactionDOMElement.addEventListener("touchmove", this.onPointerMove, true);
      }
      this.eventsAdded = true;
    }
  }, {
    key: "removeEvents",
    value: function removeEvents() {
      if (!this.interactionDOMElement) {
        return;
      }
      this.emit("removeevents");
      this.interactionDOMElement.removeEventListener("click", this.onClick, true);
      if (window.navigator.msPointerEnabled) {
        this.interactionDOMElement.style["-ms-content-zooming"] = "";
        this.interactionDOMElement.style["-ms-touch-action"] = "";
      } else if (this.supportsPointerEvents) {
        this.interactionDOMElement.style["touch-action"] = "";
      }
      if (this.supportsPointerEvents) {
        window.document.removeEventListener("pointermove", this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener("pointerdown", this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener("pointerleave", this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener("pointerover", this.onPointerOver, true);
        window.removeEventListener("pointercancel", this.onPointerCancel, true);
        window.removeEventListener("pointerup", this.onPointerUp, true);
      } else {
        window.document.removeEventListener("mousemove", this.onPointerMove, true);
        this.interactionDOMElement.removeEventListener("mousedown", this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener("mouseout", this.onPointerOut, true);
        this.interactionDOMElement.removeEventListener("mouseover", this.onPointerOver, true);
        window.removeEventListener("mouseup", this.onPointerUp, true);
      }
      if (this.supportsTouchEvents) {
        this.interactionDOMElement.removeEventListener("touchstart", this.onPointerDown, true);
        this.interactionDOMElement.removeEventListener("touchcancel", this.onPointerCancel, true);
        this.interactionDOMElement.removeEventListener("touchend", this.onPointerUp, true);
        this.interactionDOMElement.removeEventListener("touchmove", this.onPointerMove, true);
      }
      this.interactionDOMElement = null;
      this.eventsAdded = false;
    }
  }, {
    key: "update",
    value: function update(_ref) {
      var snippet = _ref.snippet;
      if (!this.isAble())
        return;
      this._deltaTime += snippet;
      if (this._deltaTime < this.interactionFrequency) {
        return;
      }
      this._deltaTime = 0;
      if (!this.interactionDOMElement) {
        return;
      }
      if (this.didMove) {
        this.didMove = false;
        return;
      }
      this.cursor = null;
      for (var k in this.activeInteractionData) {
        if (this.activeInteractionData.hasOwnProperty(k)) {
          var interactionData = this.activeInteractionData[k];
          if (interactionData.originalEvent && interactionData.pointerType !== "touch") {
            var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, interactionData.originalEvent, interactionData);
            this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, true);
          }
        }
      }
      this.setCursorMode(this.cursor);
    }
  }, {
    key: "setCursorMode",
    value: function setCursorMode(mode) {
      mode = mode || "default";
      if (this.currentCursorMode === mode) {
        return;
      }
      this.currentCursorMode = mode;
      var style = this.cursorStyles[mode];
      if (style) {
        switch (typeof style === "undefined" ? "undefined" : _typeof(style)) {
          case "string":
            this.interactionDOMElement.style.cursor = style;
            break;
          case "function":
            style(mode);
            break;
          case "object":
            Object.assign(this.interactionDOMElement.style, style);
            break;
          default:
            break;
        }
      } else if (typeof mode === "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {
        this.interactionDOMElement.style.cursor = mode;
      }
    }
  }, {
    key: "triggerEvent",
    value: function triggerEvent(displayObject, eventString, eventData) {
      if (!eventData.stopped) {
        eventData.currentTarget = displayObject;
        eventData.type = eventString;
        displayObject.emit(eventString, eventData);
        if (displayObject[eventString]) {
          displayObject[eventString](eventData);
        }
      }
    }
  }, {
    key: "processInteractive",
    value: function processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {
      if (!displayObject || !displayObject.visible) {
        return false;
      }
      interactive = displayObject.interactive || interactive;
      var hit = false;
      var interactiveParent = interactive;
      if (displayObject.interactiveChildren && displayObject.children) {
        var children = displayObject.children;
        for (var i = children.length - 1; i >= 0; i--) {
          var child = children[i];
          var childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);
          if (childHit) {
            if (!child.parent) {
              continue;
            }
            interactiveParent = false;
            if (childHit) {
              if (interactionEvent.target) {
                hitTest = false;
              }
              hit = true;
            }
          }
        }
      }
      if (interactive) {
        if (hitTest && !interactionEvent.target) {
          if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {
            hit = true;
          }
        }
        if (displayObject.interactive) {
          if (hit && !interactionEvent.target) {
            interactionEvent.data.target = interactionEvent.target = displayObject;
          }
          if (func) {
            func(interactionEvent, displayObject, !!hit);
          }
        }
      }
      return hit;
    }
  }, {
    key: "onClick",
    value: function onClick(originalEvent) {
      if (!this.isAble())
        return;
      if (originalEvent.type !== "click")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }
      var interactionData = this.getInteractionDataForPointerId(events[0]);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);
      interactionEvent.data.originalEvent = originalEvent;
      this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);
      this.emit("click", interactionEvent);
    }
  }, {
    key: "processClick",
    value: function processClick(interactionEvent, displayObject, hit) {
      if (hit) {
        this.triggerEvent(displayObject, "click", interactionEvent);
      }
    }
  }, {
    key: "onPointerDown",
    value: function onPointerDown(originalEvent) {
      if (!this.isAble())
        return;
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        originalEvent.preventDefault();
      }
      var eventLen = events.length;
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);
        this.emit("pointerdown", interactionEvent);
        if (event.pointerType === "touch") {
          this.emit("touchstart", interactionEvent);
        } else if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightdown" : "mousedown", this.eventData);
        }
      }
    }
  }, {
    key: "processPointerDown",
    value: function processPointerDown(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      if (hit) {
        if (!displayObject.trackedPointers[id]) {
          displayObject.trackedPointers[id] = new InteractionTrackingData(id);
        }
        this.triggerEvent(displayObject, "pointerdown", interactionEvent);
        if (data.pointerType === "touch") {
          displayObject.started = true;
          this.triggerEvent(displayObject, "touchstart", interactionEvent);
        } else if (data.pointerType === "mouse" || data.pointerType === "pen") {
          var isRightButton = data.button === 2;
          if (isRightButton) {
            displayObject.trackedPointers[id].rightDown = true;
          } else {
            displayObject.trackedPointers[id].leftDown = true;
          }
          this.triggerEvent(displayObject, isRightButton ? "rightdown" : "mousedown", interactionEvent);
        }
      }
    }
  }, {
    key: "onPointerComplete",
    value: function onPointerComplete(originalEvent, cancelled, func) {
      var events = this.normalizeToPointerData(originalEvent);
      var eventLen = events.length;
      var eventAppend = originalEvent.target !== this.interactionDOMElement ? "outside" : "";
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);
        this.emit(cancelled ? "pointercancel" : "pointerup" + eventAppend, interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen") {
          var isRightButton = event.button === 2;
          this.emit(isRightButton ? "rightup" + eventAppend : "mouseup" + eventAppend, interactionEvent);
        } else if (event.pointerType === "touch") {
          this.emit(cancelled ? "touchcancel" : "touchend" + eventAppend, interactionEvent);
          this.releaseInteractionDataForPointerId(event.pointerId, interactionData);
        }
      }
    }
  }, {
    key: "onPointerCancel",
    value: function onPointerCancel(event) {
      if (!this.isAble())
        return;
      if (this.supportsTouchEvents && event.pointerType === "touch")
        return;
      this.onPointerComplete(event, true, this.processPointerCancel);
    }
  }, {
    key: "processPointerCancel",
    value: function processPointerCancel(interactionEvent, displayObject) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      if (displayObject.trackedPointers[id] !== void 0) {
        delete displayObject.trackedPointers[id];
        this.triggerEvent(displayObject, "pointercancel", interactionEvent);
        if (data.pointerType === "touch") {
          this.triggerEvent(displayObject, "touchcancel", interactionEvent);
        }
      }
    }
  }, {
    key: "onPointerUp",
    value: function onPointerUp(event) {
      if (!this.isAble())
        return;
      if (this.supportsTouchEvents && event.pointerType === "touch")
        return;
      this.onPointerComplete(event, false, this.processPointerUp);
    }
  }, {
    key: "processPointerUp",
    value: function processPointerUp(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var trackingData = displayObject.trackedPointers[id];
      var isTouch = data.pointerType === "touch";
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      if (isMouse) {
        var isRightButton = data.button === 2;
        var flags = InteractionTrackingData.FLAGS;
        var test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;
        var isDown = trackingData !== void 0 && trackingData.flags & test;
        if (hit) {
          this.triggerEvent(displayObject, isRightButton ? "rightup" : "mouseup", interactionEvent);
          if (isDown) {
            this.triggerEvent(displayObject, isRightButton ? "rightclick" : "leftclick", interactionEvent);
          }
        } else if (isDown) {
          this.triggerEvent(displayObject, isRightButton ? "rightupoutside" : "mouseupoutside", interactionEvent);
        }
        if (trackingData) {
          if (isRightButton) {
            trackingData.rightDown = false;
          } else {
            trackingData.leftDown = false;
          }
        }
      }
      if (isTouch && displayObject.started) {
        displayObject.started = false;
        this.triggerEvent(displayObject, "touchend", interactionEvent);
      }
      if (hit) {
        this.triggerEvent(displayObject, "pointerup", interactionEvent);
        if (trackingData) {
          this.triggerEvent(displayObject, "pointertap", interactionEvent);
          if (isTouch) {
            this.triggerEvent(displayObject, "tap", interactionEvent);
            trackingData.over = false;
          }
        }
      } else if (trackingData) {
        this.triggerEvent(displayObject, "pointerupoutside", interactionEvent);
        if (isTouch)
          this.triggerEvent(displayObject, "touchendoutside", interactionEvent);
      }
      if (trackingData && trackingData.none) {
        delete displayObject.trackedPointers[id];
      }
    }
  }, {
    key: "onPointerMove",
    value: function onPointerMove(originalEvent) {
      if (!this.isAble())
        return;
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      if (events[0].pointerType === "mouse") {
        this.didMove = true;
        this.cursor = null;
      }
      var eventLen = events.length;
      for (var i = 0; i < eventLen; i++) {
        var event = events[i];
        var interactionData = this.getInteractionDataForPointerId(event);
        var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
        interactionEvent.data.originalEvent = originalEvent;
        var interactive = event.pointerType === "touch" ? this.moveWhenInside : true;
        this.processInteractive(interactionEvent, this.layer.scene, this.processPointerMove, interactive);
        this.emit("pointermove", interactionEvent);
        if (event.pointerType === "touch")
          this.emit("touchmove", interactionEvent);
        if (event.pointerType === "mouse" || event.pointerType === "pen")
          this.emit("mousemove", interactionEvent);
      }
      if (events[0].pointerType === "mouse") {
        this.setCursorMode(this.cursor);
      }
    }
  }, {
    key: "processPointerMove",
    value: function processPointerMove(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var isTouch = data.pointerType === "touch";
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      if (isMouse) {
        this.processPointerOverOut(interactionEvent, displayObject, hit);
      }
      if (isTouch && displayObject.started)
        this.triggerEvent(displayObject, "touchmove", interactionEvent);
      if (!this.moveWhenInside || hit) {
        this.triggerEvent(displayObject, "pointermove", interactionEvent);
        if (isMouse)
          this.triggerEvent(displayObject, "mousemove", interactionEvent);
      }
    }
  }, {
    key: "onPointerOut",
    value: function onPointerOut(originalEvent) {
      if (!this.isAble())
        return;
      if (this.supportsTouchEvents && originalEvent.pointerType === "touch")
        return;
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = false;
        this.setCursorMode(null);
      }
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);
      this.emit("pointerout", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseout", interactionEvent);
      } else {
        this.releaseInteractionDataForPointerId(interactionData.identifier);
      }
    }
  }, {
    key: "processPointerOverOut",
    value: function processPointerOverOut(interactionEvent, displayObject, hit) {
      var data = interactionEvent.data;
      var id = interactionEvent.data.identifier;
      var isMouse = data.pointerType === "mouse" || data.pointerType === "pen";
      var trackingData = displayObject.trackedPointers[id];
      if (hit && !trackingData) {
        trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);
      }
      if (trackingData === void 0)
        return;
      if (hit && this.mouseOverRenderer) {
        if (!trackingData.over) {
          trackingData.over = true;
          this.triggerEvent(displayObject, "pointerover", interactionEvent);
          if (isMouse) {
            this.triggerEvent(displayObject, "mouseover", interactionEvent);
          }
        }
        if (isMouse && this.cursor === null) {
          this.cursor = displayObject.cursor;
        }
      } else if (trackingData.over) {
        trackingData.over = false;
        this.triggerEvent(displayObject, "pointerout", this.eventData);
        if (isMouse) {
          this.triggerEvent(displayObject, "mouseout", interactionEvent);
        }
        if (trackingData.none) {
          delete displayObject.trackedPointers[id];
        }
      }
    }
  }, {
    key: "onPointerOver",
    value: function onPointerOver(originalEvent) {
      if (!this.isAble())
        return;
      var events = this.normalizeToPointerData(originalEvent);
      var event = events[0];
      var interactionData = this.getInteractionDataForPointerId(event);
      var interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);
      interactionEvent.data.originalEvent = event;
      if (event.pointerType === "mouse") {
        this.mouseOverRenderer = true;
      }
      this.emit("pointerover", interactionEvent);
      if (event.pointerType === "mouse" || event.pointerType === "pen") {
        this.emit("mouseover", interactionEvent);
      }
    }
  }, {
    key: "getInteractionDataForPointerId",
    value: function getInteractionDataForPointerId(event) {
      var pointerId = event.pointerId;
      var interactionData = void 0;
      if (pointerId === MOUSE_POINTER_ID$1 || event.pointerType === "mouse") {
        interactionData = this.mouse;
      } else if (this.activeInteractionData[pointerId]) {
        interactionData = this.activeInteractionData[pointerId];
      } else {
        interactionData = this.interactionDataPool.pop() || new InteractionData();
        interactionData.identifier = pointerId;
        this.activeInteractionData[pointerId] = interactionData;
      }
      interactionData._copyEvent(event);
      return interactionData;
    }
  }, {
    key: "releaseInteractionDataForPointerId",
    value: function releaseInteractionDataForPointerId(pointerId) {
      var interactionData = this.activeInteractionData[pointerId];
      if (interactionData) {
        delete this.activeInteractionData[pointerId];
        interactionData._reset();
        this.interactionDataPool.push(interactionData);
      }
    }
  }, {
    key: "mapPositionToPoint",
    value: function mapPositionToPoint(point, x, y) {
      var rect = void 0;
      if (!this.interactionDOMElement.parentElement) {
        rect = {
          x: 0,
          y: 0,
          left: 0,
          top: 0,
          width: 0,
          height: 0
        };
      } else {
        rect = this.interactionDOMElement.getBoundingClientRect();
      }
      point.x = (x - rect.left) / rect.width * 2 - 1;
      point.y = -((y - rect.top) / rect.height) * 2 + 1;
    }
  }, {
    key: "configureInteractionEventForDOMEvent",
    value: function configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {
      interactionEvent.data = interactionData;
      this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);
      if (this.layer && this.layer.interactive)
        this.raycaster.setFromCamera(interactionData.global, this.layer.camera);
      if (pointerEvent.pointerType === "touch") {
        pointerEvent.globalX = interactionData.global.x;
        pointerEvent.globalY = interactionData.global.y;
      }
      interactionData.originalEvent = pointerEvent;
      interactionEvent._reset();
      interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);
      return interactionEvent;
    }
  }, {
    key: "normalizeToPointerData",
    value: function normalizeToPointerData(event) {
      var normalizedEvents = [];
      if (this.supportsTouchEvents && event instanceof TouchEvent) {
        for (var i = 0, li = event.changedTouches.length; i < li; i++) {
          var touch = event.changedTouches[i];
          if (typeof touch.button === "undefined")
            touch.button = event.touches.length ? 1 : 0;
          if (typeof touch.buttons === "undefined")
            touch.buttons = event.touches.length ? 1 : 0;
          if (typeof touch.isPrimary === "undefined") {
            touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
          }
          if (typeof touch.width === "undefined")
            touch.width = touch.radiusX || 1;
          if (typeof touch.height === "undefined")
            touch.height = touch.radiusY || 1;
          if (typeof touch.tiltX === "undefined")
            touch.tiltX = 0;
          if (typeof touch.tiltY === "undefined")
            touch.tiltY = 0;
          if (typeof touch.pointerType === "undefined")
            touch.pointerType = "touch";
          if (typeof touch.pointerId === "undefined")
            touch.pointerId = touch.identifier || 0;
          if (typeof touch.pressure === "undefined")
            touch.pressure = touch.force || 0.5;
          touch.twist = 0;
          touch.tangentialPressure = 0;
          if (typeof touch.layerX === "undefined")
            touch.layerX = touch.offsetX = touch.clientX;
          if (typeof touch.layerY === "undefined")
            touch.layerY = touch.offsetY = touch.clientY;
          touch.isNormalized = true;
          normalizedEvents.push(touch);
        }
      } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {
        if (typeof event.isPrimary === "undefined")
          event.isPrimary = true;
        if (typeof event.width === "undefined")
          event.width = 1;
        if (typeof event.height === "undefined")
          event.height = 1;
        if (typeof event.tiltX === "undefined")
          event.tiltX = 0;
        if (typeof event.tiltY === "undefined")
          event.tiltY = 0;
        if (typeof event.pointerType === "undefined")
          event.pointerType = "mouse";
        if (typeof event.pointerId === "undefined")
          event.pointerId = MOUSE_POINTER_ID$1;
        if (typeof event.pressure === "undefined")
          event.pressure = 0.5;
        event.twist = 0;
        event.tangentialPressure = 0;
        event.isNormalized = true;
        normalizedEvents.push(event);
      } else {
        normalizedEvents.push(event);
      }
      return normalizedEvents;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.removeEvents();
      this.removeAllListeners();
      this.renderer = null;
      this.mouse = null;
      this.eventData = null;
      this.interactionDOMElement = null;
      this.onPointerDown = null;
      this.processPointerDown = null;
      this.onPointerUp = null;
      this.processPointerUp = null;
      this.onPointerCancel = null;
      this.processPointerCancel = null;
      this.onPointerMove = null;
      this.processPointerMove = null;
      this.onPointerOut = null;
      this.processPointerOverOut = null;
      this.onPointerOver = null;
      this._tempPoint = null;
    }
  }]);
  return InteractionLayer2;
}(EventDispatcher);
(function() {
  var lastTime = 0;
  var vendors = ["ms", "moz", "webkit", "o"];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame = window[vendors[x] + "CancelAnimationFrame"] || window[vendors[x] + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function(callback) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function() {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function(id) {
      clearTimeout(id);
    };
  }
  window.RAF = window.requestAnimationFrame;
  window.CAF = window.cancelAnimationFrame;
})();
var Ticker = function(_EventDispatcher) {
  inherits(Ticker2, _EventDispatcher);
  function Ticker2() {
    classCallCheck(this, Ticker2);
    var _this = possibleConstructorReturn(this, (Ticker2.__proto__ || Object.getPrototypeOf(Ticker2)).call(this));
    _this.timer = null;
    _this.started = false;
    _this.pt = 0;
    _this.snippet = 0;
    _this.start();
    return _this;
  }
  createClass(Ticker2, [{
    key: "start",
    value: function start() {
      var _this2 = this;
      if (this.started)
        return;
      var loop = function loop2() {
        _this2.timeline();
        _this2.emit("tick", { snippet: _this2.snippet });
        _this2.timer = RAF(loop2);
      };
      loop();
    }
  }, {
    key: "stop",
    value: function stop() {
      CAF(this.timer);
      this.started = false;
    }
  }, {
    key: "timeline",
    value: function timeline() {
      this.snippet = Date.now() - this.pt;
      if (this.pt === 0 || this.snippet > 200) {
        this.pt = Date.now();
        this.snippet = Date.now() - this.pt;
      }
      this.pt += this.snippet;
    }
  }]);
  return Ticker2;
}(EventDispatcher);
var Interaction = function(_InteractionManager) {
  inherits(Interaction2, _InteractionManager);
  function Interaction2(renderer, scene, camera, options) {
    classCallCheck(this, Interaction2);
    options = Object.assign({ autoAttach: false }, options);
    var _this = possibleConstructorReturn(this, (Interaction2.__proto__ || Object.getPrototypeOf(Interaction2)).call(this, renderer, scene, camera, options));
    _this.ticker = new Ticker();
    _this.update = _this.update.bind(_this);
    _this.on("addevents", function() {
      _this.ticker.on("tick", _this.update);
    });
    _this.on("removeevents", function() {
      _this.ticker.off("tick", _this.update);
    });
    _this.setTargetElement(_this.renderer.domElement);
    return _this;
  }
  return Interaction2;
}(InteractionManager);
export {
  Interaction,
  InteractionLayer,
  InteractionManager
};
//# sourceMappingURL=three_interaction.js.map
