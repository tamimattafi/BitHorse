{
  "version": 3,
  "sources": ["../three.interaction/src/utils/Utils.js", "../three.interaction/src/patch/EventDispatcher.js", "../three.interaction/src/patch/Object3D.js", "../three.interaction/src/interaction/InteractionData.js", "../three.interaction/src/interaction/InteractionEvent.js", "../three.interaction/src/interaction/InteractionTrackingData.js", "../three.interaction/src/interaction/InteractionManager.js", "../three.interaction/src/interaction/InteractionLayer.js", "../three.interaction/src/utils/Raf.js", "../three.interaction/src/utils/Ticker.js", "../three.interaction/src/interaction/Interaction.js"],
  "sourcesContent": ["/**\n * get variable type\n * @param {*} val a variable which you want to get the type\n * @return {String} variable-type\n */\nfunction _rt(val) {\n  return Object.prototype.toString.call(val);\n}\n\n/**\n * Utils tool box\n *\n * @namespace Utils\n */\nexport const Utils = {\n  /**\n   * determine whether it is a `Function`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isFunction: (function() {\n    const ks = _rt(function() {});\n    return function(variable) {\n      return _rt(variable) === ks;\n    };\n  })(),\n\n\n  /**\n   * determine whether it is a `undefined`\n   *\n   * @static\n   * @method\n   * @memberof Utils\n   * @param {*} variable a variable which you want to determine\n   * @return {Boolean} type result\n   */\n  isUndefined(variable) {\n    return typeof variable === 'undefined';\n  },\n};\n", "import { EventDispatcher, Object3D } from 'three';\nimport { Utils } from '../utils/Utils.js';\n\n/**\n * proxy `addEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.on = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  if (this instanceof Object3D) this.interactive = true;\n  this.addEventListener(type, fn);\n  return this;\n};\n\n/**\n * proxy `removeEventListener` function\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback, which you had bind before\n * @return {this} this\n */\nEventDispatcher.prototype.off = function(type, fn) {\n  this.removeEventListener(type, fn);\n  return this;\n};\n\n/**\n * binding a once event, just emit once time\n *\n * @param {String} type event type, evnet name\n * @param {Function} fn callback\n * @return {this} this\n */\nEventDispatcher.prototype.once = function(type, fn) {\n  if (!Utils.isFunction(fn)) return;\n  const cb = (ev) => {\n    fn(ev);\n    this.off(type, cb);\n  };\n  this.on(type, cb);\n  return this;\n};\n\n/**\n * emit a event\n *\n * @param {String} type event type, evnet name\n * @return {this} this\n */\nEventDispatcher.prototype.emit = function(type, ...argument) {\n  if (this._listeners === undefined || Utils.isUndefined(this._listeners[type])) return;\n  const cbs = this._listeners[type] || [];\n  const cache = cbs.slice(0);\n\n  for (let i = 0; i < cache.length; i++) {\n    cache[i].apply(this, argument);\n  }\n  return this;\n};\n\n", "import { Object3D } from 'three';\n\n/**\n * whether displayObject is interactively\n */\nObject3D.prototype.interactive = false;\n\n/**\n * whether displayObject's children is interactively\n */\nObject3D.prototype.interactiveChildren = true;\n\n/**\n * whether displayObject had touchstart\n * @private\n */\nObject3D.prototype.started = false;\n\n/**\n * tracked event cache, like: touchend\u3001mouseout\u3001pointerout which decided by primary-event\n */\nObject.defineProperty(Object3D.prototype, 'trackedPointers', {\n  get() {\n    if (!this._trackedPointers) this._trackedPointers = {};\n    return this._trackedPointers;\n  },\n});\n\n/**\n * dispatch a raycast\n *\n * @param {Raycaster} raycaster Raycaster object, get from THREE.Raycaster\n * @return {Object|Boolean} had pass hit-test\n */\nObject3D.prototype.raycastTest = function(raycaster) {\n  const result = [];\n  this.raycast(raycaster, result);\n\n  if (result.length > 0) {\n    return result[0];\n  }\n\n  return false;\n};\n", "import { Vector2 } from 'three';\n\n/**\n * Holds all information related to an Interaction event\n *\n * @class\n */\nclass InteractionData {\n  /**\n   * InteractionData constructor\n   */\n  constructor() {\n    /**\n     * This point stores the global coords of where the touch/mouse event happened\n     *\n     * @member {Vector2}\n     */\n    this.global = new Vector2();\n\n    /**\n     * The target DisplayObject that was interacted with\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * When passed to an event handler, this will be the original DOM Event that was captured\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent\n     * @member {MouseEvent|TouchEvent|PointerEvent}\n     */\n    this.originalEvent = null;\n\n    /**\n     * Unique identifier for this interaction\n     *\n     * @member {number}\n     */\n    this.identifier = null;\n\n    /**\n     * Indicates whether or not the pointer device that created the event is the primary pointer.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/isPrimary\n     * @type {Boolean}\n     */\n    this.isPrimary = false;\n\n    /**\n     * Indicates which button was pressed on the mouse or pointer device to trigger the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n     * @type {number}\n     */\n    this.button = 0;\n\n    /**\n     * Indicates which buttons are pressed on the mouse or pointer device when the event is triggered.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\n     * @type {number}\n     */\n    this.buttons = 0;\n\n    /**\n     * The width of the pointer's contact along the x-axis, measured in CSS pixels.\n     * radiusX of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/width\n     * @type {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the pointer's contact along the y-axis, measured in CSS pixels.\n     * radiusY of TouchEvents will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/height\n     * @type {number}\n     */\n    this.height = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX\n     * @type {number}\n     */\n    this.tiltX = 0;\n\n    /**\n     * The angle, in degrees, between the pointer device and the screen.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY\n     * @type {number}\n     */\n    this.tiltY = 0;\n\n    /**\n     * The type of pointer that triggered the event.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType\n     * @type {string}\n     */\n    this.pointerType = null;\n\n    /**\n     * Pressure applied by the pointing device during the event. A Touch's force property\n     * will be represented by this value.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure\n     * @type {number}\n     */\n    this.pressure = 0;\n\n    /**\n     * From TouchEvents (not PointerEvents triggered by touches), the rotationAngle of the Touch.\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/Touch/rotationAngle\n     * @type {number}\n     */\n    this.rotationAngle = 0;\n\n    /**\n     * Twist of a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.twist = 0;\n\n    /**\n     * Barrel pressure on a stylus pointer.\n     * @see https://w3c.github.io/pointerevents/#pointerevent-interface\n     * @type {number}\n     */\n    this.tangentialPressure = 0;\n  }\n\n  /**\n   * The unique identifier of the pointer. It will be the same as `identifier`.\n   * @readonly\n   * @member {number}\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerId\n   */\n  get pointerId() {\n    return this.identifier;\n  }\n\n  /**\n   * Copies properties from normalized event data.\n   *\n   * @param {Touch|MouseEvent|PointerEvent} event The normalized event data\n   * @private\n   */\n  _copyEvent(event) {\n    // isPrimary should only change on touchstart/pointerdown, so we don't want to overwrite\n    // it with \"false\" on later events when our shim for it on touch events might not be\n    // accurate\n    if (event.isPrimary) {\n      this.isPrimary = true;\n    }\n    this.button = event.button;\n    this.buttons = event.buttons;\n    this.width = event.width;\n    this.height = event.height;\n    this.tiltX = event.tiltX;\n    this.tiltY = event.tiltY;\n    this.pointerType = event.pointerType;\n    this.pressure = event.pressure;\n    this.rotationAngle = event.rotationAngle;\n    this.twist = event.twist || 0;\n    this.tangentialPressure = event.tangentialPressure || 0;\n  }\n\n  /**\n   * Resets the data for pooling.\n   *\n   * @private\n   */\n  _reset() {\n    // isPrimary is the only property that we really need to reset - everything else is\n    // guaranteed to be overwritten\n    this.isPrimary = false;\n  }\n}\n\nexport default InteractionData;\n", "/**\n * Event class that mimics native DOM events.\n *\n * @class\n */\nclass InteractionEvent {\n  /**\n   * InteractionEvent constructor\n   */\n  constructor() {\n    /**\n     * Whether this event will continue propagating in the tree\n     *\n     * @member {boolean}\n     */\n    this.stopped = false;\n\n    /**\n     * The object which caused this event to be dispatched.\n     *\n     * @member {Object3D}\n     */\n    this.target = null;\n\n    /**\n     * The object whose event listener\u2019s callback is currently being invoked.\n     *\n     * @member {Object3D}\n     */\n    this.currentTarget = null;\n\n    /**\n     * Type of the event\n     *\n     * @member {string}\n     */\n    this.type = null;\n\n    /**\n     * InteractionData related to this event\n     *\n     * @member {InteractionData}\n     */\n    this.data = null;\n\n    /**\n     * ray caster detial from 3d-mesh\n     *\n     * @member {Intersects}\n     */\n    this.intersects = [];\n  }\n\n  /**\n   * Prevents event from reaching any objects other than the current object.\n   *\n   */\n  stopPropagation() {\n    this.stopped = true;\n  }\n\n  /**\n   * Resets the event.\n   *\n   * @private\n   */\n  _reset() {\n    this.stopped = false;\n    this.currentTarget = null;\n    this.target = null;\n    this.intersects = [];\n  }\n}\n\nexport default InteractionEvent;\n", "/**\n * DisplayObjects with the `trackedPointers` property use this class to track interactions\n *\n * @class\n * @private\n */\nexport default class InteractionTrackingData {\n  /**\n   * @param {number} pointerId - Unique pointer id of the event\n   */\n  constructor(pointerId) {\n    this._pointerId = pointerId;\n    this._flags = InteractionTrackingData.FLAGS.NONE;\n  }\n\n  /**\n   *\n   * @private\n   * @param {number} flag - The interaction flag to set\n   * @param {boolean} yn - Should the flag be set or unset\n   */\n  _doSet(flag, yn) {\n    if (yn) {\n      this._flags = this._flags | flag;\n    } else {\n      this._flags = this._flags & (~flag);\n    }\n  }\n\n  /**\n   * Unique pointer id of the event\n   *\n   * @readonly\n   * @member {number}\n   */\n  get pointerId() {\n    return this._pointerId;\n  }\n\n  /**\n   * State of the tracking data, expressed as bit flags\n   *\n   * @member {number}\n   */\n  get flags() {\n    return this._flags;\n  }\n\n  /**\n   * Set the flags for the tracking data\n   *\n   * @param {number} flags - Flags to set\n   */\n  set flags(flags) {\n    this._flags = flags;\n  }\n\n  /**\n   * Is the tracked event inactive (not over or down)?\n   *\n   * @member {number}\n   */\n  get none() {\n    return this._flags === this.constructor.FLAGS.NONE;\n  }\n\n  /**\n   * Is the tracked event over the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get over() {\n    return (this._flags & this.constructor.FLAGS.OVER) !== 0;\n  }\n\n  /**\n   * Set the over flag\n   *\n   * @param {boolean} yn - Is the event over?\n   */\n  set over(yn) {\n    this._doSet(this.constructor.FLAGS.OVER, yn);\n  }\n\n  /**\n   * Did the right mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get rightDown() {\n    return (this._flags & this.constructor.FLAGS.RIGHT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the right down flag\n   *\n   * @param {boolean} yn - Is the right mouse button down?\n   */\n  set rightDown(yn) {\n    this._doSet(this.constructor.FLAGS.RIGHT_DOWN, yn);\n  }\n\n  /**\n   * Did the left mouse button come down in the DisplayObject?\n   *\n   * @member {boolean}\n   */\n  get leftDown() {\n    return (this._flags & this.constructor.FLAGS.LEFT_DOWN) !== 0;\n  }\n\n  /**\n   * Set the left down flag\n   *\n   * @param {boolean} yn - Is the left mouse button down?\n   */\n  set leftDown(yn) {\n    this._doSet(this.constructor.FLAGS.LEFT_DOWN, yn);\n  }\n}\n\nInteractionTrackingData.FLAGS = Object.freeze({\n  NONE: 0,\n  OVER: 1 << 0,\n  LEFT_DOWN: 1 << 1,\n  RIGHT_DOWN: 1 << 2,\n});\n", "import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionManager extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionManager#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionManager#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionManager#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionManager#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionManager#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionManager#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionManager#event:mousedown}.\n     *\n     * @event InteractionManager#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionManager#event:rightdown}.\n     *\n     * @event InteractionManager#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionManager#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionManager#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionManager#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionManager#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionManager#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionManager#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionManager#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionManager#event:pointerdown}.\n     *\n     * @event InteractionManager#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionManager#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionManager#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionManager#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionManager#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionManager#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionManager#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionManager#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionManager#event:touchstart}.\n     *\n     * @event InteractionManager#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionManager#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    this.raycaster.setFromCamera(interactionData.global, this.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionManager;\n", "import '../patch/EventDispatcher';\nimport '../patch/Object3D';\n\nimport { EventDispatcher, Raycaster } from 'three';\nimport InteractionData from './InteractionData';\nimport InteractionEvent from './InteractionEvent';\nimport InteractionTrackingData from './InteractionTrackingData';\n\nconst MOUSE_POINTER_ID = 'MOUSE';\n\n// helpers for hitTest() - only used inside hitTest()\nconst hitTestEvent = {\n  target: null,\n  data: {\n    global: null,\n  },\n};\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @private\n * @class\n * @extends EventDispatcher\n */\nclass InteractionLayer extends EventDispatcher {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=true] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, options) {\n    super();\n\n    options = options || {};\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Layer}\n     */\n    this.layer = null;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Scene}\n     */\n    // this.scene = scene;\n\n    /**\n     * The renderer this interaction manager works for.\n     *\n     * @member {Camera}\n     */\n    // this.camera = camera;\n\n    /**\n     * Should default browser actions automatically be prevented.\n     * Does not apply to pointer events for backwards compatibility\n     * preventDefault on pointer events stops mouse events from firing\n     * Thus, for every pointer event, there will always be either a mouse of touch event alongside it.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoPreventDefault = options.autoPreventDefault || false;\n\n    /**\n     * Frequency in milliseconds that the mousemove, moveover & mouseout interaction events will be checked.\n     *\n     * @member {number}\n     * @default 10\n     */\n    this.interactionFrequency = options.interactionFrequency || 10;\n\n    /**\n     * The mouse data\n     *\n     * @member {InteractionData}\n     */\n    this.mouse = new InteractionData();\n    this.mouse.identifier = MOUSE_POINTER_ID;\n\n    // setting the mouse to start off far off screen will mean that mouse over does\n    //  not get called before we even move the mouse.\n    this.mouse.global.set(-999999);\n\n    /**\n     * Actively tracked InteractionData\n     *\n     * @private\n     * @member {Object.<number,InteractionData>}\n     */\n    this.activeInteractionData = {};\n    this.activeInteractionData[MOUSE_POINTER_ID] = this.mouse;\n\n    /**\n     * Pool of unused InteractionData\n     *\n     * @private\n     * @member {InteractionData[]}\n     */\n    this.interactionDataPool = [];\n\n    /**\n     * An event data object to handle all the event tracking/dispatching\n     *\n     * @member {object}\n     */\n    this.eventData = new InteractionEvent();\n\n    /**\n     * The DOM element to bind to.\n     *\n     * @private\n     * @member {HTMLElement}\n     */\n    this.interactionDOMElement = null;\n\n    /**\n     * This property determines if mousemove and touchmove events are fired only when the cursor\n     * is over the object.\n     * Setting to true will make things work more in line with how the DOM verison works.\n     * Setting to false can make things easier for things like dragging\n     * It is currently set to false as this is how three.js used to work.\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.moveWhenInside = true;\n\n    /**\n     * Have events been attached to the dom element?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.eventsAdded = false;\n\n    /**\n     * Is the mouse hovering over the renderer?\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.mouseOverRenderer = false;\n\n    /**\n     * Does the device support touch events\n     * https://www.w3.org/TR/touch-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsTouchEvents = 'ontouchstart' in window;\n\n    /**\n     * Does the device support pointer events\n     * https://www.w3.org/Submission/pointer-events/\n     *\n     * @readonly\n     * @member {boolean}\n     */\n    this.supportsPointerEvents = !!window.PointerEvent;\n\n    // this will make it so that you don't have to call bind all the time\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onClick = this.onClick.bind(this);\n    this.processClick = this.processClick.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerUp = this.onPointerUp.bind(this);\n    this.processPointerUp = this.processPointerUp.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerCancel = this.onPointerCancel.bind(this);\n    this.processPointerCancel = this.processPointerCancel.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerDown = this.onPointerDown.bind(this);\n    this.processPointerDown = this.processPointerDown.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerMove = this.onPointerMove.bind(this);\n    this.processPointerMove = this.processPointerMove.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOut = this.onPointerOut.bind(this);\n    this.processPointerOverOut = this.processPointerOverOut.bind(this);\n\n    /**\n     * @private\n     * @member {Function}\n     */\n    this.onPointerOver = this.onPointerOver.bind(this);\n\n    /**\n     * Dictionary of how different cursor modes are handled. Strings are handled as CSS cursor\n     * values, objects are handled as dictionaries of CSS values for interactionDOMElement,\n     * and functions are called instead of changing the CSS.\n     * Default CSS cursor values are provided for 'default' and 'pointer' modes.\n     * @member {Object.<string, (string|Function|Object.<string, string>)>}\n     */\n    this.cursorStyles = {\n      default: 'inherit',\n      pointer: 'pointer',\n    };\n\n    /**\n     * The mode of the cursor that is being used.\n     * The value of this is a key from the cursorStyles dictionary.\n     *\n     * @member {string}\n     */\n    this.currentCursorMode = null;\n\n    /**\n     * Internal cached let.\n     *\n     * @private\n     * @member {string}\n     */\n    this.cursor = null;\n\n    /**\n     * ray caster, for survey intersects from 3d-scene\n     *\n     * @private\n     * @member {Raycaster}\n     */\n    this.raycaster = new Raycaster();\n\n    /**\n     * snippet time\n     *\n     * @private\n     * @member {Number}\n     */\n    this._deltaTime = 0;\n\n    this.setTargetElement(this.renderer.domElement);\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display\n     * object.\n     *\n     * @event InteractionLayer#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object.\n     *\n     * @event InteractionLayer#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object.\n     *\n     * @event InteractionLayer#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object.\n     *\n     * @event InteractionLayer#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object.\n     *\n     * @event InteractionLayer#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object.\n     *\n     * @event InteractionLayer#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link InteractionLayer#event:mousedown}.\n     *\n     * @event InteractionLayer#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link InteractionLayer#event:rightdown}.\n     *\n     * @event InteractionLayer#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object\n     *\n     * @event InteractionLayer#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object\n     *\n     * @event InteractionLayer#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object\n     *\n     * @event InteractionLayer#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     *\n     * @event InteractionLayer#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     *\n     * @event InteractionLayer#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event\n     *\n     * @event InteractionLayer#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     *\n     * @event InteractionLayer#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link InteractionLayer#event:pointerdown}.\n     *\n     * @event InteractionLayer#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object\n     *\n     * @event InteractionLayer#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object\n     *\n     * @event InteractionLayer#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object\n     *\n     * @event InteractionLayer#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     *\n     * @event InteractionLayer#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     *\n     * @event InteractionLayer#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch\n     *\n     * @event InteractionLayer#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     *\n     * @event InteractionLayer#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link InteractionLayer#event:touchstart}.\n     *\n     * @event InteractionLayer#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     *\n     * @event InteractionLayer#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed on the display.\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousedown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released over the display\n     * object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * over the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is pressed and released on\n     * the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#click\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is pressed\n     * and released on the display object. DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightclick\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button (usually a mouse left-button) is released outside the\n     * display object that initially registered a\n     * [mousedown]{@link Object3D#event:mousedown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device secondary button (usually a mouse right-button) is released\n     * outside the display object that initially registered a\n     * [rightdown]{@link Object3D#event:rightdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#rightupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mousemove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device (usually a mouse) is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#mouseout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerdown\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerup\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a pointer event.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointercancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is pressed and released on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointertap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device button is released outside the display object that initially\n     * registered a [pointerdown]{@link Object3D#event:pointerdown}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerupoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved while over the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointermove\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved onto the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerover\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a pointer device is moved off the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#pointerout\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed on the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchstart\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchend\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when the operating system cancels a touch.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchcancel\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is placed and removed from the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#tap\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is removed outside of the display object that initially\n     * registered a [touchstart]{@link Object3D#event:touchstart}.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchendoutside\n     * @param {InteractionEvent} event - Interaction event\n     */\n\n    /**\n     * Fired when a touch point is moved along the display object.\n     * DisplayObject's `interactive` property must be set to `true` to fire event.\n     *\n     * @event Object3D#touchmove\n     * @param {InteractionEvent} event - Interaction event\n     */\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isAble() {\n    return this.layer && this.layer.interactive;\n  }\n\n  /**\n   * set layer\n   * @param {Layer} layer layer\n   */\n  setLayer(layer) {\n    this.layer = layer;\n  }\n\n  /**\n   * Hit tests a point against the display tree, returning the first interactive object that is hit.\n   *\n   * @param {Point} globalPoint - A point to hit test with, in global space.\n   * @param {Object3D} [root] - The root display object to start from. If omitted, defaults\n   * to the last rendered root of the associated renderer.\n   * @return {Object3D} The hit display object, if any.\n   */\n  hitTest(globalPoint, root) {\n    if (!this.isAble()) return null;\n    // clear the target for our hit test\n    hitTestEvent.target = null;\n    // assign the global point\n    hitTestEvent.data.global = globalPoint;\n    // ensure safety of the root\n    if (!root) {\n      root = this.layer.scene;\n    }\n    // run the hit test\n    this.processInteractive(hitTestEvent, root, null, true);\n    // return our found object - it'll be null if we didn't hit anything\n\n    return hitTestEvent.target;\n  }\n\n  /**\n   * Sets the DOM element which will receive mouse/touch events. This is useful for when you have\n   * other DOM elements on top of the renderers Canvas element. With this you'll be bale to deletegate\n   * another DOM element to receive those events.\n   *\n   * @param {HTMLCanvasElement} element - the DOM element which will receive mouse and touch events.\n   */\n  setTargetElement(element) {\n    this.removeEvents();\n\n    this.interactionDOMElement = element;\n\n    this.addEvents();\n  }\n\n  /**\n   * Registers all the DOM events\n   *\n   * @private\n   */\n  addEvents() {\n    if (!this.interactionDOMElement || this.eventsAdded) {\n      return;\n    }\n\n    this.emit('addevents');\n\n    this.interactionDOMElement.addEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = 'none';\n      this.interactionDOMElement.style['-ms-touch-action'] = 'none';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = 'none';\n    }\n\n    /**\n     * These events are added first, so that if pointer events are normalised, they are fired\n     * in the same order as non-normalised events. ie. pointer event 1st, mouse / touch 2nd\n     */\n    if (this.supportsPointerEvents) {\n      window.document.addEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('pointerdown', this.onPointerDown, true);\n      // pointerout is fired in addition to pointerup (for touch events) and pointercancel\n      // we already handle those, so for the purposes of what we do in onPointerOut, we only\n      // care about the pointerleave event\n      this.interactionDOMElement.addEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('pointerover', this.onPointerOver, true);\n      window.addEventListener('pointercancel', this.onPointerCancel, true);\n      window.addEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.addEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.addEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.addEventListener('mouseover', this.onPointerOver, true);\n      window.addEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    // always look directly for touch events so that we can provide original data\n    // In a future version we should change this to being just a fallback and rely solely on\n    // PointerEvents whenever available\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.addEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.addEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.addEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.addEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.eventsAdded = true;\n  }\n\n  /**\n   * Removes all the DOM events that were previously registered\n   *\n   * @private\n   */\n  removeEvents() {\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    this.emit('removeevents');\n\n    this.interactionDOMElement.removeEventListener('click', this.onClick, true);\n\n    if (window.navigator.msPointerEnabled) {\n      this.interactionDOMElement.style['-ms-content-zooming'] = '';\n      this.interactionDOMElement.style['-ms-touch-action'] = '';\n    } else if (this.supportsPointerEvents) {\n      this.interactionDOMElement.style['touch-action'] = '';\n    }\n\n    if (this.supportsPointerEvents) {\n      window.document.removeEventListener('pointermove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('pointerdown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('pointerleave', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('pointerover', this.onPointerOver, true);\n      window.removeEventListener('pointercancel', this.onPointerCancel, true);\n      window.removeEventListener('pointerup', this.onPointerUp, true);\n    } else {\n      window.document.removeEventListener('mousemove', this.onPointerMove, true);\n      this.interactionDOMElement.removeEventListener('mousedown', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('mouseout', this.onPointerOut, true);\n      this.interactionDOMElement.removeEventListener('mouseover', this.onPointerOver, true);\n      window.removeEventListener('mouseup', this.onPointerUp, true);\n    }\n\n    if (this.supportsTouchEvents) {\n      this.interactionDOMElement.removeEventListener('touchstart', this.onPointerDown, true);\n      this.interactionDOMElement.removeEventListener('touchcancel', this.onPointerCancel, true);\n      this.interactionDOMElement.removeEventListener('touchend', this.onPointerUp, true);\n      this.interactionDOMElement.removeEventListener('touchmove', this.onPointerMove, true);\n    }\n\n    this.interactionDOMElement = null;\n\n    this.eventsAdded = false;\n  }\n\n  /**\n   * Updates the state of interactive objects.\n   * Invoked by a throttled ticker.\n   *\n   * @param {number} deltaTime - time delta since last tick\n   */\n  update({ snippet }) {\n    if (!this.isAble()) return;\n    this._deltaTime += snippet;\n\n    if (this._deltaTime < this.interactionFrequency) {\n      return;\n    }\n\n    this._deltaTime = 0;\n\n    if (!this.interactionDOMElement) {\n      return;\n    }\n\n    // if the user move the mouse this check has already been done using the mouse move!\n    if (this.didMove) {\n      this.didMove = false;\n\n      return;\n    }\n\n    this.cursor = null;\n\n    // Resets the flag as set by a stopPropagation call. This flag is usually reset by a user interaction of any kind,\n    // but there was a scenario of a display object moving under a static mouse cursor.\n    // In this case, mouseover and mouseevents would not pass the flag test in triggerEvent function\n    for (const k in this.activeInteractionData) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.activeInteractionData.hasOwnProperty(k)) {\n        const interactionData = this.activeInteractionData[k];\n\n        if (interactionData.originalEvent && interactionData.pointerType !== 'touch') {\n          const interactionEvent = this.configureInteractionEventForDOMEvent(\n            this.eventData,\n            interactionData.originalEvent,\n            interactionData\n          );\n\n          this.processInteractive(\n            interactionEvent,\n            this.layer.scene,\n            this.processPointerOverOut,\n            true\n          );\n        }\n      }\n    }\n\n    this.setCursorMode(this.cursor);\n\n    // TODO\n  }\n\n  /**\n   * Sets the current cursor mode, handling any callbacks or CSS style changes.\n   *\n   * @param {string} mode - cursor mode, a key from the cursorStyles dictionary\n   */\n  setCursorMode(mode) {\n    mode = mode || 'default';\n    // if the mode didn't actually change, bail early\n    if (this.currentCursorMode === mode) {\n      return;\n    }\n    this.currentCursorMode = mode;\n    const style = this.cursorStyles[mode];\n\n    // only do things if there is a cursor style for it\n    if (style) {\n      switch (typeof style) {\n        case 'string':\n          // string styles are handled as cursor CSS\n          this.interactionDOMElement.style.cursor = style;\n          break;\n        case 'function':\n          // functions are just called, and passed the cursor mode\n          style(mode);\n          break;\n        case 'object':\n          // if it is an object, assume that it is a dictionary of CSS styles,\n          // apply it to the interactionDOMElement\n          Object.assign(this.interactionDOMElement.style, style);\n          break;\n        default:\n          break;\n      }\n    } else if (typeof mode === 'string' && !Object.prototype.hasOwnProperty.call(this.cursorStyles, mode)) {\n      // if it mode is a string (not a Symbol) and cursorStyles doesn't have any entry\n      // for the mode, then assume that the dev wants it to be CSS for the cursor.\n      this.interactionDOMElement.style.cursor = mode;\n    }\n  }\n\n  /**\n   * Dispatches an event on the display object that was interacted with\n   *\n   * @param {Object3D} displayObject - the display object in question\n   * @param {string} eventString - the name of the event (e.g, mousedown)\n   * @param {object} eventData - the event data object\n   * @private\n   */\n  triggerEvent(displayObject, eventString, eventData) {\n    if (!eventData.stopped) {\n      eventData.currentTarget = displayObject;\n      eventData.type = eventString;\n\n      displayObject.emit(eventString, eventData);\n\n      if (displayObject[eventString]) {\n        displayObject[eventString](eventData);\n      }\n    }\n  }\n\n  /**\n   * This function is provides a neat way of crawling through the scene graph and running a\n   * specified function on all interactive objects it finds. It will also take care of hit\n   * testing the interactive objects and passes the hit across in the function.\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - event containing the point that\n   *  is tested for collision\n   * @param {Object3D} displayObject - the displayObject\n   *  that will be hit test (recursively crawls its children)\n   * @param {Function} [func] - the function that will be called on each interactive object. The\n   *  interactionEvent, displayObject and hit will be passed to the function\n   * @param {boolean} [hitTest] - this indicates if the objects inside should be hit test against the point\n   * @param {boolean} [interactive] - Whether the displayObject is interactive\n   * @return {boolean} returns true if the displayObject hit the point\n   */\n  processInteractive(interactionEvent, displayObject, func, hitTest, interactive) {\n    if (!displayObject || !displayObject.visible) {\n      return false;\n    }\n\n    // Took a little while to rework this function correctly! But now it is done and nice and optimised. ^_^\n    //\n    // This function will now loop through all objects and then only hit test the objects it HAS\n    // to, not all of them. MUCH faster..\n    // An object will be hit test if the following is true:\n    //\n    // 1: It is interactive.\n    // 2: It belongs to a parent that is interactive AND one of the parents children have not already been hit.\n    //\n    // As another little optimisation once an interactive object has been hit we can carry on\n    // through the scenegraph, but we know that there will be no more hits! So we can avoid extra hit tests\n    // A final optimisation is that an object is not hit test directly if a child has already been hit.\n\n    interactive = displayObject.interactive || interactive;\n\n    let hit = false;\n    let interactiveParent = interactive;\n\n    if (displayObject.interactiveChildren && displayObject.children) {\n      const children = displayObject.children;\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n\n        // time to get recursive.. if this function will return if something is hit..\n        const childHit = this.processInteractive(interactionEvent, child, func, hitTest, interactiveParent);\n\n        if (childHit) {\n          // its a good idea to check if a child has lost its parent.\n          // this means it has been removed whilst looping so its best\n          if (!child.parent) {\n            continue;\n          }\n\n          // we no longer need to hit test any more objects in this container as we we\n          // now know the parent has been hit\n          interactiveParent = false;\n\n          // If the child is interactive , that means that the object hit was actually\n          // interactive and not just the child of an interactive object.\n          // This means we no longer need to hit test anything else. We still need to run\n          // through all objects, but we don't need to perform any hit tests.\n\n          if (childHit) {\n            if (interactionEvent.target) {\n              hitTest = false;\n            }\n            hit = true;\n          }\n        }\n      }\n    }\n\n    // no point running this if the item is not interactive or does not have an interactive parent.\n    if (interactive) {\n      // if we are hit testing (as in we have no hit any objects yet)\n      // We also don't need to worry about hit testing if once of the displayObjects children\n      // has already been hit - but only if it was interactive, otherwise we need to keep\n      // looking for an interactive child, just in case we hit one\n      if (hitTest && !interactionEvent.target) {\n        if (interactionEvent.intersects[0] && interactionEvent.intersects[0].object === displayObject) {\n          hit = true;\n        }\n      }\n\n      if (displayObject.interactive) {\n        if (hit && !interactionEvent.target) {\n          interactionEvent.data.target = interactionEvent.target = displayObject;\n        }\n\n        if (func) {\n          func(interactionEvent, displayObject, !!hit);\n        }\n      }\n    }\n\n    return hit;\n  }\n\n\n  /**\n   * Is called when the click is pressed down on the renderer element\n   *\n   * @private\n   * @param {MouseEvent} originalEvent - The DOM event of a click being pressed down\n   */\n  onClick(originalEvent) {\n    if (!this.isAble()) return;\n    if (originalEvent.type !== 'click') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(events[0]);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, events[0], interactionData);\n\n    interactionEvent.data.originalEvent = originalEvent;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processClick, true);\n\n    this.emit('click', interactionEvent);\n  }\n\n  /**\n   * Processes the result of the click check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processClick(interactionEvent, displayObject, hit) {\n    if (hit) {\n      this.triggerEvent(displayObject, 'click', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer button is pressed down on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being pressed down\n   */\n  onPointerDown(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    /**\n     * No need to prevent default on natural pointer events, as there are no side effects\n     * Normalized events, however, may have the double mousedown/touchstart issue on the native android browser,\n     * so still need to be prevented.\n     */\n\n    // Guaranteed that there will be at least one event in events, and all events must have the same pointer type\n\n    if (this.autoPreventDefault && events[0].isNormalized) {\n      originalEvent.preventDefault();\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      this.processInteractive(interactionEvent, this.layer.scene, this.processPointerDown, true);\n\n      this.emit('pointerdown', interactionEvent);\n      if (event.pointerType === 'touch') {\n        this.emit('touchstart', interactionEvent);\n      } else if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? 'rightdown' : 'mousedown', this.eventData);\n      }\n    }\n  }\n\n  /**\n   * Processes the result of the pointer down check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerDown(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n    const id = interactionEvent.data.identifier;\n\n    if (hit) {\n      if (!displayObject.trackedPointers[id]) {\n        displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n      }\n      this.triggerEvent(displayObject, 'pointerdown', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        displayObject.started = true;\n        this.triggerEvent(displayObject, 'touchstart', interactionEvent);\n      } else if (data.pointerType === 'mouse' || data.pointerType === 'pen') {\n        const isRightButton = data.button === 2;\n\n        if (isRightButton) {\n          displayObject.trackedPointers[id].rightDown = true;\n        } else {\n          displayObject.trackedPointers[id].leftDown = true;\n        }\n\n        this.triggerEvent(displayObject, isRightButton ? 'rightdown' : 'mousedown', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being released\n   * @param {boolean} cancelled - true if the pointer is cancelled\n   * @param {Function} func - Function passed to {@link processInteractive}\n   */\n  onPointerComplete(originalEvent, cancelled, func) {\n    const events = this.normalizeToPointerData(originalEvent);\n\n    const eventLen = events.length;\n\n    // if the event wasn't targeting our canvas, then consider it to be pointerupoutside\n    // in all cases (unless it was a pointercancel)\n    const eventAppend = originalEvent.target !== this.interactionDOMElement ? 'outside' : '';\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      // perform hit testing for events targeting our canvas or cancel events\n      this.processInteractive(interactionEvent, this.layer.scene, func, cancelled || !eventAppend);\n\n      this.emit(cancelled ? 'pointercancel' : `pointerup${eventAppend}`, interactionEvent);\n\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n        const isRightButton = event.button === 2;\n\n        this.emit(isRightButton ? `rightup${eventAppend}` : `mouseup${eventAppend}`, interactionEvent);\n      } else if (event.pointerType === 'touch') {\n        this.emit(cancelled ? 'touchcancel' : `touchend${eventAppend}`, interactionEvent);\n        this.releaseInteractionDataForPointerId(event.pointerId, interactionData);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is cancelled\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerCancel(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, true, this.processPointerCancel);\n  }\n\n  /**\n   * Processes the result of the pointer cancel check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   */\n  processPointerCancel(interactionEvent, displayObject) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    if (displayObject.trackedPointers[id] !== undefined) {\n      delete displayObject.trackedPointers[id];\n      this.triggerEvent(displayObject, 'pointercancel', interactionEvent);\n\n      if (data.pointerType === 'touch') {\n        this.triggerEvent(displayObject, 'touchcancel', interactionEvent);\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer button is released on the renderer element\n   *\n   * @private\n   * @param {PointerEvent} event - The DOM event of a pointer button being released\n   */\n  onPointerUp(event) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && event.pointerType === 'touch') return;\n\n    this.onPointerComplete(event, false, this.processPointerUp);\n  }\n\n  /**\n   * Processes the result of the pointer up check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerUp(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const trackingData = displayObject.trackedPointers[id];\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    // Mouse only\n    if (isMouse) {\n      const isRightButton = data.button === 2;\n\n      const flags = InteractionTrackingData.FLAGS;\n\n      const test = isRightButton ? flags.RIGHT_DOWN : flags.LEFT_DOWN;\n\n      const isDown = trackingData !== undefined && (trackingData.flags & test);\n\n      if (hit) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightup' : 'mouseup', interactionEvent);\n\n        if (isDown) {\n          this.triggerEvent(displayObject, isRightButton ? 'rightclick' : 'leftclick', interactionEvent);\n        }\n      } else if (isDown) {\n        this.triggerEvent(displayObject, isRightButton ? 'rightupoutside' : 'mouseupoutside', interactionEvent);\n      }\n      // update the down state of the tracking data\n      if (trackingData) {\n        if (isRightButton) {\n          trackingData.rightDown = false;\n        } else {\n          trackingData.leftDown = false;\n        }\n      }\n    }\n\n    // Pointers and Touches, and Mouse\n    if (isTouch && displayObject.started) {\n      displayObject.started = false;\n      this.triggerEvent(displayObject, 'touchend', interactionEvent);\n    }\n    if (hit) {\n      this.triggerEvent(displayObject, 'pointerup', interactionEvent);\n\n      if (trackingData) {\n        this.triggerEvent(displayObject, 'pointertap', interactionEvent);\n        if (isTouch) {\n          this.triggerEvent(displayObject, 'tap', interactionEvent);\n          // touches are no longer over (if they ever were) when we get the touchend\n          // so we should ensure that we don't keep pretending that they are\n          trackingData.over = false;\n        }\n      }\n    } else if (trackingData) {\n      this.triggerEvent(displayObject, 'pointerupoutside', interactionEvent);\n      if (isTouch) this.triggerEvent(displayObject, 'touchendoutside', interactionEvent);\n    }\n    // Only remove the tracking data if there is no over/down state still associated with it\n    if (trackingData && trackingData.none) {\n      delete displayObject.trackedPointers[id];\n    }\n  }\n\n  /**\n   * Is called when the pointer moves across the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer moving\n   */\n  onPointerMove(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    if (events[0].pointerType === 'mouse') {\n      this.didMove = true;\n\n      this.cursor = null;\n    }\n\n    const eventLen = events.length;\n\n    for (let i = 0; i < eventLen; i++) {\n      const event = events[i];\n\n      const interactionData = this.getInteractionDataForPointerId(event);\n\n      const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n      interactionEvent.data.originalEvent = originalEvent;\n\n      const interactive = event.pointerType === 'touch' ? this.moveWhenInside : true;\n\n      this.processInteractive(\n        interactionEvent,\n        this.layer.scene,\n        this.processPointerMove,\n        interactive\n      );\n      this.emit('pointermove', interactionEvent);\n      if (event.pointerType === 'touch') this.emit('touchmove', interactionEvent);\n      if (event.pointerType === 'mouse' || event.pointerType === 'pen') this.emit('mousemove', interactionEvent);\n    }\n\n    if (events[0].pointerType === 'mouse') {\n      this.setCursorMode(this.cursor);\n\n      // TODO BUG for parents interactive object (border order issue)\n    }\n  }\n\n  /**\n   * Processes the result of the pointer move check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerMove(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const isTouch = data.pointerType === 'touch';\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    if (isMouse) {\n      this.processPointerOverOut(interactionEvent, displayObject, hit);\n    }\n\n    if (isTouch && displayObject.started) this.triggerEvent(displayObject, 'touchmove', interactionEvent);\n    if (!this.moveWhenInside || hit) {\n      this.triggerEvent(displayObject, 'pointermove', interactionEvent);\n      if (isMouse) this.triggerEvent(displayObject, 'mousemove', interactionEvent);\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved out of the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer being moved out\n   */\n  onPointerOut(originalEvent) {\n    if (!this.isAble()) return;\n    // if we support touch events, then only use those for touch events, not pointer events\n    if (this.supportsTouchEvents && originalEvent.pointerType === 'touch') return;\n\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOut, so events will always be length 1\n    const event = events[0];\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = false;\n      this.setCursorMode(null);\n    }\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    this.processInteractive(interactionEvent, this.layer.scene, this.processPointerOverOut, false);\n\n    this.emit('pointerout', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseout', interactionEvent);\n    } else {\n      // we can get touchleave events after touchend, so we want to make sure we don't\n      // introduce memory leaks\n      this.releaseInteractionDataForPointerId(interactionData.identifier);\n    }\n  }\n\n  /**\n   * Processes the result of the pointer over/out check and dispatches the event if need be\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The interaction event wrapping the DOM event\n   * @param {Object3D} displayObject - The display object that was tested\n   * @param {boolean} hit - the result of the hit test on the display object\n   */\n  processPointerOverOut(interactionEvent, displayObject, hit) {\n    const data = interactionEvent.data;\n\n    const id = interactionEvent.data.identifier;\n\n    const isMouse = (data.pointerType === 'mouse' || data.pointerType === 'pen');\n\n    let trackingData = displayObject.trackedPointers[id];\n\n    // if we just moused over the display object, then we need to track that state\n    if (hit && !trackingData) {\n      trackingData = displayObject.trackedPointers[id] = new InteractionTrackingData(id);\n    }\n\n    if (trackingData === undefined) return;\n\n    if (hit && this.mouseOverRenderer) {\n      if (!trackingData.over) {\n        trackingData.over = true;\n        this.triggerEvent(displayObject, 'pointerover', interactionEvent);\n        if (isMouse) {\n          this.triggerEvent(displayObject, 'mouseover', interactionEvent);\n        }\n      }\n\n      // only change the cursor if it has not already been changed (by something deeper in the\n      // display tree)\n      if (isMouse && this.cursor === null) {\n        this.cursor = displayObject.cursor;\n      }\n    } else if (trackingData.over) {\n      trackingData.over = false;\n      this.triggerEvent(displayObject, 'pointerout', this.eventData);\n      if (isMouse) {\n        this.triggerEvent(displayObject, 'mouseout', interactionEvent);\n      }\n      // if there is no mouse down information for the pointer, then it is safe to delete\n      if (trackingData.none) {\n        delete displayObject.trackedPointers[id];\n      }\n    }\n  }\n\n  /**\n   * Is called when the pointer is moved into the renderer element\n   *\n   * @private\n   * @param {PointerEvent} originalEvent - The DOM event of a pointer button being moved into the renderer view\n   */\n  onPointerOver(originalEvent) {\n    if (!this.isAble()) return;\n    const events = this.normalizeToPointerData(originalEvent);\n\n    // Only mouse and pointer can call onPointerOver, so events will always be length 1\n    const event = events[0];\n\n    const interactionData = this.getInteractionDataForPointerId(event);\n\n    const interactionEvent = this.configureInteractionEventForDOMEvent(this.eventData, event, interactionData);\n\n    interactionEvent.data.originalEvent = event;\n\n    if (event.pointerType === 'mouse') {\n      this.mouseOverRenderer = true;\n    }\n\n    this.emit('pointerover', interactionEvent);\n    if (event.pointerType === 'mouse' || event.pointerType === 'pen') {\n      this.emit('mouseover', interactionEvent);\n    }\n  }\n\n  /**\n   * Get InteractionData for a given pointerId. Store that data as well\n   *\n   * @private\n   * @param {PointerEvent} event - Normalized pointer event, output from normalizeToPointerData\n   * @return {InteractionData} - Interaction data for the given pointer identifier\n   */\n  getInteractionDataForPointerId(event) {\n    const pointerId = event.pointerId;\n\n    let interactionData;\n\n    if (pointerId === MOUSE_POINTER_ID || event.pointerType === 'mouse') {\n      interactionData = this.mouse;\n    } else if (this.activeInteractionData[pointerId]) {\n      interactionData = this.activeInteractionData[pointerId];\n    } else {\n      interactionData = this.interactionDataPool.pop() || new InteractionData();\n      interactionData.identifier = pointerId;\n      this.activeInteractionData[pointerId] = interactionData;\n    }\n    // copy properties from the event, so that we can make sure that touch/pointer specific\n    // data is available\n    interactionData._copyEvent(event);\n\n    return interactionData;\n  }\n\n  /**\n   * Return unused InteractionData to the pool, for a given pointerId\n   *\n   * @private\n   * @param {number} pointerId - Identifier from a pointer event\n   */\n  releaseInteractionDataForPointerId(pointerId) {\n    const interactionData = this.activeInteractionData[pointerId];\n\n    if (interactionData) {\n      delete this.activeInteractionData[pointerId];\n      interactionData._reset();\n      this.interactionDataPool.push(interactionData);\n    }\n  }\n\n  /**\n   * Maps x and y coords from a DOM object and maps them correctly to the three.js view. The\n   * resulting value is stored in the point. This takes into account the fact that the DOM\n   * element could be scaled and positioned anywhere on the screen.\n   *\n   * @param  {Vector2} point - the point that the result will be stored in\n   * @param  {number} x - the x coord of the position to map\n   * @param  {number} y - the y coord of the position to map\n   */\n  mapPositionToPoint(point, x, y) {\n    let rect;\n\n    // IE 11 fix\n    if (!this.interactionDOMElement.parentElement) {\n      rect = {\n        x: 0,\n        y: 0,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n      };\n    } else {\n      rect = this.interactionDOMElement.getBoundingClientRect();\n    }\n\n    point.x = ((x - rect.left) / rect.width) * 2 - 1;\n    point.y = -((y - rect.top) / rect.height) * 2 + 1;\n  }\n\n  /**\n   * Configure an InteractionEvent to wrap a DOM PointerEvent and InteractionData\n   *\n   * @private\n   * @param {InteractionEvent} interactionEvent - The event to be configured\n   * @param {PointerEvent} pointerEvent - The DOM event that will be paired with the InteractionEvent\n   * @param {InteractionData} interactionData - The InteractionData that will be paired\n   *        with the InteractionEvent\n   * @return {InteractionEvent} the interaction event that was passed in\n   */\n  configureInteractionEventForDOMEvent(interactionEvent, pointerEvent, interactionData) {\n    interactionEvent.data = interactionData;\n\n    this.mapPositionToPoint(interactionData.global, pointerEvent.clientX, pointerEvent.clientY);\n\n    if (this.layer && this.layer.interactive) this.raycaster.setFromCamera(interactionData.global, this.layer.camera);\n\n    // Not really sure why this is happening, but it's how a previous version handled things TODO: there should be remove\n    if (pointerEvent.pointerType === 'touch') {\n      pointerEvent.globalX = interactionData.global.x;\n      pointerEvent.globalY = interactionData.global.y;\n    }\n\n    interactionData.originalEvent = pointerEvent;\n    interactionEvent._reset();\n    interactionEvent.intersects = this.raycaster.intersectObjects(this.scene.children, true);\n\n    return interactionEvent;\n  }\n\n  /**\n   * Ensures that the original event object contains all data that a regular pointer event would have\n   *\n   * @private\n   * @param {TouchEvent|MouseEvent|PointerEvent} event - The original event data from a touch or mouse event\n   * @return {PointerEvent[]} An array containing a single normalized pointer event, in the case of a pointer\n   *  or mouse event, or a multiple normalized pointer events if there are multiple changed touches\n   */\n  normalizeToPointerData(event) {\n    const normalizedEvents = [];\n\n    if (this.supportsTouchEvents && event instanceof TouchEvent) {\n      for (let i = 0, li = event.changedTouches.length; i < li; i++) {\n        const touch = event.changedTouches[i];\n\n        if (typeof touch.button === 'undefined') touch.button = event.touches.length ? 1 : 0;\n        if (typeof touch.buttons === 'undefined') touch.buttons = event.touches.length ? 1 : 0;\n        if (typeof touch.isPrimary === 'undefined') {\n          touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';\n        }\n        if (typeof touch.width === 'undefined') touch.width = touch.radiusX || 1;\n        if (typeof touch.height === 'undefined') touch.height = touch.radiusY || 1;\n        if (typeof touch.tiltX === 'undefined') touch.tiltX = 0;\n        if (typeof touch.tiltY === 'undefined') touch.tiltY = 0;\n        if (typeof touch.pointerType === 'undefined') touch.pointerType = 'touch';\n        if (typeof touch.pointerId === 'undefined') touch.pointerId = touch.identifier || 0;\n        if (typeof touch.pressure === 'undefined') touch.pressure = touch.force || 0.5;\n        touch.twist = 0;\n        touch.tangentialPressure = 0;\n        // TODO: Remove these, as layerX/Y is not a standard, is deprecated, has uneven\n        // support, and the fill ins are not quite the same\n        // offsetX/Y might be okay, but is not the same as clientX/Y when the canvas's top\n        // left is not 0,0 on the page\n        if (typeof touch.layerX === 'undefined') touch.layerX = touch.offsetX = touch.clientX;\n        if (typeof touch.layerY === 'undefined') touch.layerY = touch.offsetY = touch.clientY;\n\n        // mark the touch as normalized, just so that we know we did it\n        touch.isNormalized = true;\n\n        normalizedEvents.push(touch);\n      }\n    } else if (event instanceof MouseEvent && (!this.supportsPointerEvents || !(event instanceof window.PointerEvent))) {\n      if (typeof event.isPrimary === 'undefined') event.isPrimary = true;\n      if (typeof event.width === 'undefined') event.width = 1;\n      if (typeof event.height === 'undefined') event.height = 1;\n      if (typeof event.tiltX === 'undefined') event.tiltX = 0;\n      if (typeof event.tiltY === 'undefined') event.tiltY = 0;\n      if (typeof event.pointerType === 'undefined') event.pointerType = 'mouse';\n      if (typeof event.pointerId === 'undefined') event.pointerId = MOUSE_POINTER_ID;\n      if (typeof event.pressure === 'undefined') event.pressure = 0.5;\n      event.twist = 0;\n      event.tangentialPressure = 0;\n\n      // mark the mouse event as normalized, just so that we know we did it\n      event.isNormalized = true;\n\n      normalizedEvents.push(event);\n    } else {\n      normalizedEvents.push(event);\n    }\n\n    return normalizedEvents;\n  }\n\n  /**\n   * Destroys the interaction manager\n   *\n   */\n  destroy() {\n    this.removeEvents();\n\n    this.removeAllListeners();\n\n    this.renderer = null;\n\n    this.mouse = null;\n\n    this.eventData = null;\n\n    this.interactionDOMElement = null;\n\n    this.onPointerDown = null;\n    this.processPointerDown = null;\n\n    this.onPointerUp = null;\n    this.processPointerUp = null;\n\n    this.onPointerCancel = null;\n    this.processPointerCancel = null;\n\n    this.onPointerMove = null;\n    this.processPointerMove = null;\n\n    this.onPointerOut = null;\n    this.processPointerOverOut = null;\n\n    this.onPointerOver = null;\n\n    this._tempPoint = null;\n  }\n}\n\nexport default InteractionLayer;\n", "(function() {\n  let lastTime = 0;\n  let vendors = ['ms', 'moz', 'webkit', 'o'];\n  for (let x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\n    window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];\n    window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] ||\n            window[vendors[x] + 'CancelRequestAnimationFrame'];\n  }\n\n  if (!window.requestAnimationFrame) {\n    window.requestAnimationFrame = function(callback) {\n      let currTime = new Date().getTime();\n      let timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      let id = window.setTimeout(function() {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function(id) {\n      clearTimeout(id);\n    };\n  }\n\n  window.RAF = window.requestAnimationFrame;\n  window.CAF = window.cancelAnimationFrame;\n})();\n", "import './Raf';\nimport { EventDispatcher } from 'three';\n\n/**\n * @extends EventDispatcher\n */\nclass Ticker extends EventDispatcher {\n  /**\n   *\n   */\n  constructor() {\n    super();\n    this.timer = null;\n    this.started = false;\n\n    /**\n     * pre-time cache\n     *\n     * @member {Number}\n     * @private\n     */\n    this.pt = 0;\n\n    /**\n     * how long the time through, at this tick\n     *\n     * @member {Number}\n     * @private\n     */\n    this.snippet = 0;\n\n    this.start();\n  }\n\n  /**\n   * start tick loop\n   */\n  start() {\n    if (this.started) return;\n    const loop = () => {\n      this.timeline();\n      this.emit('tick', { snippet: this.snippet });\n      this.timer = RAF(loop);\n    };\n    loop();\n  }\n\n  /**\n   * stop tick loop\n   */\n  stop() {\n    CAF(this.timer);\n    this.started = false;\n  }\n\n  /**\n   * get timeline snippet\n   *\n   * @private\n   */\n  timeline() {\n    this.snippet = Date.now() - this.pt;\n    if (this.pt === 0 || this.snippet > 200) {\n      this.pt = Date.now();\n      this.snippet = Date.now() - this.pt;\n    }\n\n    this.pt += this.snippet;\n  }\n}\n\nexport default Ticker;\n", "import Ticker from '../utils/Ticker';\nimport InteractionManager from './InteractionManager';\n\n/**\n * The interaction manager deals with mouse, touch and pointer events. Any DisplayObject can be interactive\n * if its interactive parameter is set to true\n * This manager also supports multitouch.\n *\n * reference to [pixi.js](http://www.pixijs.com/) impl\n *\n * @example\n * import { Scene, PerspectiveCamera, WebGLRenderer, Mesh, BoxGeometry, MeshBasicMaterial } from 'three';\n * import { Interaction } from 'three.interaction';\n * const renderer = new WebGLRenderer({ canvas: canvasElement });\n * const scene = new Scene();\n * const camera = new PerspectiveCamera(60, width / height, 0.1, 100);\n *\n * const interaction = new Interaction(renderer, scene, camera);\n * // then you can bind every interaction event with any mesh which you had `add` into `scene` before\n * const cube = new Mesh(\n *   new BoxGeometry(1, 1, 1),\n *   new MeshBasicMaterial({ color: 0xffffff }),\n * );\n * scene.add(cube);\n * cube.on('touchstart', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('mousedown', ev => {\n *   console.log(ev);\n * });\n *\n * cube.on('pointerdown', ev => {\n *   console.log(ev);\n * });\n * // and so on ...\n *\n * // you can also listen on parent-node or any display-tree node,\n * // source event will bubble up along with display-tree.\n * // you can stop the bubble-up by invoke ev.stopPropagation function.\n * scene.on('touchstart', ev => {\n *   console.log(ev);\n * })\n *\n * @class\n * @extends InteractionManager\n */\nclass Interaction extends InteractionManager {\n  /**\n   * @param {WebGLRenderer} renderer - A reference to the current renderer\n   * @param {Scene} scene - A reference to the current scene\n   * @param {Camera} camera - A reference to the current camera\n   * @param {Object} [options] - The options for the manager.\n   * @param {Boolean} [options.autoPreventDefault=false] - Should the manager automatically prevent default browser actions.\n   * @param {Boolean} [options.autoAttach=false] - Should the manager automatically attach target element.\n   * @param {Number} [options.interactionFrequency=10] - Frequency increases the interaction events will be checked.\n   */\n  constructor(renderer, scene, camera, options) {\n    options = Object.assign({ autoAttach: false }, options);\n    super(renderer, scene, camera, options);\n\n    /**\n     * a ticker\n     *\n     * @private\n     * @member {Ticker}\n     */\n    this.ticker = new Ticker();\n\n    /**\n     * update for some over event\n     *\n     * @private\n     */\n    this.update = this.update.bind(this);\n\n    this.on('addevents', () => {\n      this.ticker.on('tick', this.update);\n    });\n\n    this.on('removeevents', () => {\n      this.ticker.off('tick', this.update);\n    });\n\n    this.setTargetElement(this.renderer.domElement);\n  }\n}\n\nexport default Interaction;\n"],
  "mappings": "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",
  "names": []
}
